# `symbol_table_definition.md` 文档

## 1. MCCP 符号表 (`mccp_symbols.json`) 的目的与重要性

在 MCCP (Model Context Code Protocol) 框架中，符号表 (`mccp_symbols.json`) 扮演着核心元数据仓库的角色。其主要目的在于：

* 精确记录代码结构: 详尽记录整个 MCCP 工程中定义的所有关键符号，包括全局变量、类、函数，以及文件、类内部的变量和函数。
* 管理依赖关系: 存储文件、模块或符号之间的显式或隐式依赖关系，特别体现在文件间的依赖 (`file_depend`)。
* 确保符号引用的可信性: 为大模型在生成符号-伪代码层和最终代码时提供一个可验证的“真相来源”。模型在引用任何变量、函数或类时，都应该能够在符号表中找到对应的记录，从而最大限度地避免“幻觉”问题——即模型凭空捏造不存在的函数或变量引用。
* 支持跨层级一致性: 作为连接行为描述层、符号-伪代码层和最终代码生成层的关键中间件，确保不同层级对同一符号的理解和引用保持一致。
* 辅助反向构建: 在反向构建现有代码时，符号表是优先被构建的关键组件，它承载了对现有代码结构和符号的初步识别结果。

重要性: 符号表是 MCCP 工程可信度、可控性和可维护性的基石之一。没有一个准确、完整的符号表，大模型将难以生成逻辑正确、依赖关系清晰的代码，且开发人员也难以对代码结构进行有效审查和修改。

## 2. 符号表示例 JSON 结构详解

用户提供的符号表示例 JSON 结构清晰地反映了符号在项目中的作用域层级和文件组织方式：

```json
{
    "global": { ... },
    "file1": { ... },
    "file2": { ... },
    // ... 更多文件条目
}
```

整体结构是一个顶级 JSON 对象，包含以下主要部分：

* `"global"`: 这是一个固定的顶级键，用于存储在全局作用域内可访问的符号。
* 文件特定条目: 除 `"global"` 外的其他顶级键，例如 `"file1"`, `"file2"` 等，都代表 MCCP 工程中的一个特定文件（通常对应一个行为描述层或符号-伪代码层文件）。每个文件条目存储了该文件内的符号和元数据。

这种结构通过层层嵌套，模拟了典型编程语言中的作用域链（全局 -> 文件 -> 类 -> 函数），使得符号的查找和管理更加直观和精确。

## 3. 符号表中关键字段的定义与用途

### 3.1 全局作用域 (`global`)

`global` 对象用于列举在整个项目中可以从任何地方直接引用的顶级符号。

* `"var"`:
    * 定义: 一个字符串数组，列出所有全局变量的名称。
    * 用途: 记录项目中定义的、在任何文件或函数中都可直接访问的全局变量。例如，全局配置对象、单例实例等。
    * 示例值: `["some global var", "app_config", "database_connection"]`

* `"class"`:
    * 定义: 一个字符串数组，列出所有全局作用域内定义的类名称。
    * 用途: 记录项目中定义的、可以在任何文件内通过其名称直接引用的类。在某些语言或框架中，顶级类可能被视为全局符号。
    * 示例值: `["some class name", "Application", "LoggerManager"]`

* `"func"`:
    * 定义: 一个字符串数组，列出所有全局作用域内定义的函数名称。
    * 用途: 记录项目中定义的、可以在任何文件内通过其名称直接引用的独立函数（不属于任何类）。
    * 示例值: `["some func name", "initialize_app", "shutdown_service"]`

### 3.2 文件作用域 (例如 `"file1"`, `"file2"`)

每个文件条目代表项目中的一个文件，并包含该文件的元数据及其内部定义的符号。

* `"path"`:
    * 定义: 一个字符串，表示该文件在项目中的相对路径。
    * 用途: 用于定位文件，方便大模型或工具在处理文件时进行查找和引用。
    * 示例值: `"path to file 1"`, `"src/utils.mccp_pseudo"`, `"main.mccp_pseudo"`

* `"file_depend"`:
    * 定义: 一个字符串或字符串数组，表示当前文件直接依赖的其他文件（通过 `import` 或类似机制）。
    * 用途: 记录文件间的依赖关系，指导大模型在生成代码时处理文件的顺序和跨文件符号引用。这有助于构建正确的模块导入和调用关系。
    * 示例值: `"file2"`, `["file2", "file3"]`, 或者缺失表示无显式文件依赖。

* 类级条目 (例如 `"class_a"`, `"class_b"`):
    * 定义: 每个键代表在该文件内定义的类，其值是一个对象，描述该类内部的符号。
    * 用途: 组织和记录类成员符号。
    * 内部字段:
        * `"func"`:
            * 定义: 一个字符串数组，列出该类中定义的所有成员函数（方法）的名称。
            * 用途: 记录类的行为。
            * 示例值: `["method_one", "calculate"]`
        * `"var"`:
            * 定义: 一个字符串数组，列出该类中定义的所有成员变量的名称。
            * 用途: 记录类的状态或属性。
            * 示例值: `["instance_counter", "data_cache"]`

* 文件级独立函数条目 (例如 `"func_a"`, `"func_b"`):
    * 定义: 每个键代表在该文件内定义的独立函数（不属于任何类），其值是一个对象，描述该函数内部的符号。
    * 用途: 组织和记录函数内部符号。
    * 内部字段:
        * `"var"`:
            * 定义: 一个字符串数组，列出该函数中定义的所有局部变量的名称。
            * 用途: 记录函数的局部状态或工作变量。
            * 示例值: `["temp_result", "counter"]`

* 文件级变量 (`"var"`):
    * 定义: 一个字符串数组，列出在该文件作用域内定义的变量（不属于任何类或函数）的名称。
    * 用途: 记录文件内部的全局变量或模块级变量。
    * 示例值: `["module_level_constant", "internal_state"]`

## 4. 符号表在 MCCP 工作流程中的作用

符号表是 MCCP 各个抽象层级协同工作的核心构件，尤其在行为描述层和符号-伪代码层的构建与迭代中起着至关重要的作用：

1.  行为描述层构建阶段:
    * 在大模型将自然语言需求拆解为行为描述并构建初步软件框架（文件、类、函数等）时，会初步创建符号表。
    * 此时，符号表会记录行为描述中显式提到的或根据描述推断出的主要符号（如类名、函数名、重要变量名）及其所属文件和大致作用域。这一阶段的符号表可能不包含详细的局部变量，但框架结构和关键全局/文件级符号已被捕捉。

2.  符号-伪代码层构建阶段:
    * 大模型根据行为描述层的内容生成符号-伪代码层时，会进一步填充和更新符号表。
    * 这个阶段会细化符号表，记录伪代码中出现的更具体的符号，例如函数参数、局部变量、类成员变量、以及伪代码中体现出的函数/方法调用和类实例化等关系。
    * 伪代码中的导入/依赖声明（如 `import X from "file"`）会用于填充或更新符号表中的 `file_depend` 字段，明确文件间的依赖关系。

3.  迭代与更新过程:
    * 无论是开发人员在行为描述层进行的修改，还是大模型在生成伪代码后进行的自我修正，任何引入新符号、删除符号、修改符号名称/作用域、或改变依赖关系的操作，都应触发符号表的迭代更新。
    * 大模型负责分析这些修改，并同步反映到符号表中。例如，如果行为描述增加了某个功能模块的描述，大模型可能会在符号表中新增对应的文件、类和函数条目。如果修改了某个函数的实现方式，引入了新的局部变量，符号表该函数条目下的 `var` 列表就应被更新。
    * 在每次重要的生成或修改后，符号表都应被重新验证，确保其与当前的行为描述和符号-伪代码层内容一致。

4.  符号-伪代码层的使用与验证:
    * 在生成符号-伪代码时，大模型会参考符号表，使用其中记录的规范符号名称，并根据依赖关系组织伪代码结构。
    * 生成伪代码后，可以根据符号表对伪代码中的符号引用进行静态检查，验证所有调用的函数、访问的变量是否都在符号表中存在且在当前作用域可访问，从而捕获潜在的“幻觉”引用。

5.  文件依赖管理 (`file_depend`):
    * 符号表中的 `file_depend` 字段明确记录了文件间的显式依赖。
    * 这对于大模型在最终代码生成阶段组织文件、确定编译/解释顺序（如果适用）以及生成正确的导入语句至关重要。它确保了代码生成过程能够遵循项目定义的模块化结构和依赖关系。

简而言之，符号表是 MCCP 实现“精确化、可信化、可控化”的关键技术载体，它为大模型的代码生成和项目结构的理解提供了必要且精确的元数据支持。

## 5. 符号表的维护职责与建议

符号表的准确性和完整性直接关系到整个 MCCP 工程的可信度。基于 MCCP 的设计哲学，其维护应遵循以下原则：

* 主要由大模型维护和更新: 符号表的创建、填充、以及随着行为描述层和符号-伪代码层迭代而产生的更新，应主要由大语言模型自动执行。大模型能够更全面地分析各层级内容，并根据预设规则进行符号提取和关系构建。
* 开发人员的核心职责是审查: 开发人员不应该频繁地手动修改符号表 JSON 文件。他们的核心职责是审查大模型生成的行为描述层、符号-伪代码层以及随之更新的符号表。开发人员应重点检查符号命名是否合理、作用域是否正确、依赖关系是否准确，以及符号表是否完整反映了当前的项目结构。
* 手动修改应尽量避免: 直接手动编辑 `mccp_symbols.json` 文件应尽量避免。如果开发人员发现符号表有误或需要调整，最优的方式是回到行为描述层进行相应的修改（因为行为描述层是开发者核心的投入领域），然后触发大模型根据行为描述的更新来自动修正符号表和符号-伪代码层。只有在极少数、明确需要直接干预元数据的情况下，才考虑手动修改，且修改后必须通知大模型或工具进行同步和校验。

这种维护模式确保了符号表的更新能够紧密耦合于行为描述层和伪代码层的变化，减少人为错误，并充分利用大模型在数据同步和一致性维护方面的能力。

通过上述定义和说明，开发者应能充分理解 MCCP 符号表的结构、作用及其在整个工作流程中的重要性，并明确自己在符号表维护中的角色。