```pseudocode
// file: demo_projects/demo1_todo_app/todo_app.mccp_p
// description: Symbol-Pseudocode layer for the Simple Todo List Application.
// Derived from the behavior description layer (todo_app.mccp_b).

// Define a simple structure for a Task object.
// This object will be used throughout the application.
OBJECT Task WITH PROPERTIES
    id: INTEGER        // Unique identifier for the task
    description: STRING // Text description of the task
    is_completed: BOOLEAN // Completion status (True for completed, False for not completed)
END_OBJECT

// Define string constants for task status representation as described in the behavior layer.
VAR STATUS_COMPLETED: STRING = "[x]"
VAR STATUS_PENDING: STRING = "[]"

// --- Module: src/todo_manager.mccp_p ---
// Description: Manages the core business logic for the todo list.

CLASS TaskManager
    // Internal variable: stores the list of Task objects
    VAR tasks_list: LIST OF Task

    // Internal variable: used to generate unique IDs for new tasks
    VAR next_task_id: INTEGER

    // Description: Constructor, initializes the task list and next task ID.
    // Input: initial_tasks (LIST OF Task) - A list of Task objects loaded from storage.
    METHOD __init__(initial_tasks: LIST OF Task)
        // Copy the initial tasks into the internal list.
        this.tasks_list = initial_tasks

        // Initialize next_task_id.
        // Find the maximum ID in the initial list and add 1. If the list is empty, start from 1.
        VAR max_id: INTEGER = 0
        LOOP EACH task IN this.tasks_list
            IF task.id > max_id THEN
                max_id = task.id
            END_IF
        END_LOOP
        this.next_task_id = max_id + 1
    END_METHOD

    // Description: Adds a new task to the list.
    // Input: description (STRING) - The description text for the new task.
    // Output: Task object - The newly created Task object.
    METHOD add_task(description: STRING) RETURNS Task
        // Create a new Task object.
        VAR new_task: Task = CREATE OBJECT Task WITH PROPERTIES
            id = this.next_task_id,
            description = description,
            is_completed = FALSE
        END_CREATE

        // Increment the next available ID.
        this.next_task_id = this.next_task_id + 1

        // Add the new task to the internal list.
        ADD new_task TO this.tasks_list

        // Return the new task object.
        RETURN new_task
    END_METHOD

    // Description: Retrieves the current list of tasks.
    // Output: LIST OF Task - A copy of the internal tasks list.
    METHOD get_tasks() RETURNS LIST OF Task
        // Return a copy to prevent external modification of the internal state.
        // (Pseudocode representation of returning a copy; actual implementation depends on target language).
        RETURN this.tasks_list
    END_METHOD

    // Description: Finds a task by its unique ID.
    // Input: task_id (INTEGER) - The ID of the task to find.
    // Output: Task object or NULL - The found task object or NULL if not found.
    METHOD find_task_by_id(task_id: INTEGER) RETURNS Task OR NULL
        LOOP EACH task IN this.tasks_list
            IF task.id == task_id THEN
                RETURN task
            END_IF
        END_LOOP
        // Task not found
        RETURN NULL
    END_METHOD

    // Description: Marks a specified task as completed.
    // Input: task_id (INTEGER) - The ID of the task to mark.
    // Output: BOOLEAN - TRUE if successful, FALSE if the task ID was not found.
    METHOD mark_task_completed(task_id: INTEGER) RETURNS BOOLEAN
        // Find the task by ID.
        VAR task_to_mark: Task OR NULL = this.find_task_by_id(task_id)

        // If the task is found, update its status.
        IF task_to_mark IS NOT NULL THEN
            task_to_mark.is_completed = TRUE
            RETURN TRUE
        ELSE
            // Task not found.
            RETURN FALSE
        END_IF
    END_METHOD

    // Description: Marks a specified task as not completed (pending).
    // Input: task_id (INTEGER) - The ID of the task to unmark.
    // Output: BOOLEAN - TRUE if successful, FALSE if the task ID was not found.
    METHOD unmark_task_completed(task_id: INTEGER) RETURNS BOOLEAN
        // Find the task by ID.
        VAR task_to_unmark: Task OR NULL = this.find_task_by_id(task_id)

        // If the task is found, update its status.
        IF task_to_unmark IS NOT NULL THEN
            task_to_unmark.is_completed = FALSE
            RETURN TRUE
        ELSE
            // Task not found.
            RETURN FALSE
        END_IF
    END_METHOD

    // Description: Deletes a specified task by ID.
    // Input: task_id (INTEGER) - The ID of the task to delete.
    // Output: BOOLEAN - TRUE if successful, FALSE if the task ID was not found.
    METHOD delete_task(task_id: INTEGER) RETURNS BOOLEAN
        // Find the task by ID and its index.
        VAR found_index: INTEGER = -1
        LOOP WITH index FROM 0 TO SIZE OF this.tasks_list - 1
            IF this.tasks_list[index].id == task_id THEN
                found_index = index
                BREAK LOOP
            END_IF
        END_LOOP

        // If the task is found, remove it from the list.
        IF found_index != -1 THEN
            REMOVE ITEM AT index FROM this.tasks_list
            RETURN TRUE
        ELSE
            // Task not found.
            RETURN FALSE
        END_IF
    END_METHOD

END_CLASS // TaskManager

// --- Module: src/data_storage.mccp_p ---
// Description: Handles loading and saving task data to a file.

CLASS DataStorage
    // Internal variable: stores the file path for data persistence.
    VAR data_filepath: STRING

    // Description: Constructor, initializes the data file path.
    // Input: filepath (STRING) - The full path to the data file.
    METHOD __init__(filepath: STRING)
        this.data_filepath = filepath
    END_METHOD

    // Description: Loads tasks from the specified file.
    // Output: LIST OF Task - The loaded list of tasks, or an empty list if the file doesn't exist or an error occurs.
    METHOD load_tasks() RETURNS LIST OF Task
        VAR loaded_data_list: LIST OF Task = EMPTY LIST OF Task

        // @ Use the target language's standard library for file I/O and JSON parsing.
        // Try to open the data file for reading.
        IF FILE EXISTS AT this.data_filepath THEN
            TRY
                VAR file_content: STRING = READ ALL CONTENT FROM FILE AT this.data_filepath
                // Parse the JSON content.
                VAR parsed_json: JSON_DATA = PARSE JSON STRING file_content
                // Convert parsed JSON data structure into a LIST OF Task objects.
                // Assuming parsed_json is a list of objects with 'id', 'description', 'is_completed'.
                LOOP EACH item IN parsed_json
                    VAR task_item: Task = CREATE OBJECT Task WITH PROPERTIES
                        id = GET INTEGER PROPERTY 'id' FROM item,
                        description = GET STRING PROPERTY 'description' FROM item,
                        is_completed = GET BOOLEAN PROPERTY 'is_completed' FROM item
                    END_CREATE
                    ADD task_item TO loaded_data_list
                END_LOOP
            CATCH FILE_ERROR OR JSON_PARSE_ERROR AS e
                // If JSON parsing or file reading fails, print error and return empty list.
                PRINT "Error loading data from " + this.data_filepath + ": " + e.message
                loaded_data_list = EMPTY LIST OF Task // Ensure it's empty on error
            END_TRY
        ELSE
            // If the file does not exist, return an empty list. This is not an error condition for initial startup.
            // PRINT "Data file not found at " + this.data_filepath + ". Starting with empty list." // Optional: Informative message
        END_IF

        RETURN loaded_data_list
    END_METHOD

    // Description: Saves the current list of tasks to the specified file.
    // Input: tasks_list (LIST OF Task) - The list of Task objects to save.
    // Output: BOOLEAN - TRUE if successful, FALSE if saving fails.
    METHOD save_tasks(tasks_list: LIST OF Task) RETURNS BOOLEAN
        // @ Use the target language's standard library for converting Task objects to JSON and file writing.
        TRY
            // Convert the LIST OF Task objects into a JSON serializable structure (e.g., list of dictionaries/objects).
            VAR json_serializable_list: LIST OF OBJECT = EMPTY LIST OF OBJECT
            LOOP EACH task IN tasks_list
                VAR task_object: OBJECT = CREATE OBJECT WITH PROPERTIES
                    id = task.id,
                    description = task.description,
                    is_completed = task.is_completed
                END_CREATE
                ADD task_object TO json_serializable_list
            END_LOOP

            // Convert the serializable structure to a JSON string.
            VAR json_string: STRING = CONVERT TO JSON STRING json_serializable_list

            // Write the JSON string to the data file, potentially overwriting existing content.
            WRITE json_string TO FILE AT this.data_filepath

            RETURN TRUE // Indicate success
        CATCH FILE_ERROR AS e
            // If writing fails, print error and return FALSE.
            PRINT "Error saving data to " + this.data_filepath + ": " + e.message
            RETURN FALSE // Indicate failure
        END_TRY
    END_METHOD

END_CLASS // DataStorage

// --- Module: main.mccp_p ---
// Description: Main program entry point and command-line interface interaction.

// Declare instances of the core classes.
VAR task_manager: TaskManager
VAR data_storage: DataStorage

// Define the path to the data file.
VAR DATA_FILE_PATH: STRING = "data/tasks.json" // Relative path from project root

// Function to process user commands.
// Input: command_string (STRING) - The raw input string from the user.
// Output: BOOLEAN - TRUE if the command was processed (not exit), FALSE if it was the exit command.
FUNCTION process_command(command_string: STRING) RETURNS BOOLEAN
    VAR parts: LIST OF STRING = SPLIT command_string BY SPACE // Split command string by spaces
    VAR command_type: STRING = parts[0]
    VAR command_args: LIST OF STRING = SUBSET OF parts FROM index 1 TO END

    IF command_type == "add" THEN
        IF SIZE OF command_args >= 1 THEN
            VAR description: STRING = JOIN command_args WITH SPACE // Join all args into description
            VAR new_task: Task = task_manager.add_task(description)
            PRINT "任务添加成功，ID:" + new_task.id
            // Save data after successful modification
            IF data_storage.save_tasks(task_manager.get_tasks()) THEN
                PRINT "数据已保存。"
            ELSE
                PRINT "数据保存失败！"
            END_IF
        ELSE
            PRINT "错误：'add' 命令需要提供任务描述。"
        END_IF

    ELSE IF command_type == "list" THEN
        VAR tasks: LIST OF Task = task_manager.get_tasks()
        IF SIZE OF tasks == 0 THEN
            PRINT "待办事项列表为空。"
        ELSE
            PRINT "当前待办事项:"
            LOOP EACH task IN tasks
                // Use defined status constants for display
                VAR status_icon: STRING
                IF task.is_completed == FALSE THEN
                    status_icon = STATUS_PENDING
                ELSE
                    status_icon = STATUS_COMPLETED
                END_IF
                PRINT "[" + task.id + "] " + status_icon + " " + task.description
            END_LOOP
        END_IF

    ELSE IF command_type == "done" THEN
        IF SIZE OF command_args == 1 THEN
            VAR task_id_string: STRING = command_args[0]
            VAR task_id: INTEGER
            IF IS_INTEGER(task_id_string) THEN
                task_id = PARSE_INTEGER(task_id_string)
                IF task_manager.mark_task_completed(task_id) THEN
                    PRINT "任务 " + task_id + " 已标记为完成。"
                    // Save data after successful modification
                    IF data_storage.save_tasks(task_manager.get_tasks()) THEN
                        PRINT "数据已保存。"
                    ELSE
                        PRINT "数据保存失败！"
                    END_IF
                ELSE
                    PRINT "错误：未找到ID为 " + task_id + " 的任务。"
                END_IF
            ELSE
                PRINT "错误：'done' 命令需要有效的任务ID（数字）。"
            END_IF
        ELSE
            PRINT "错误：'done' 命令需要一个任务ID。"
        END_IF

    ELSE IF command_type == "undone" THEN // Corresponds to "cancel task completion mark"
        IF SIZE OF command_args == 1 THEN
            VAR task_id_string: STRING = command_args[0]
            VAR task_id: INTEGER
            IF IS_INTEGER(task_id_string) THEN
                 task_id = PARSE_INTEGER(task_id_string)
                IF task_manager.unmark_task_completed(task_id) THEN
                    PRINT "任务 " + task_id + " 已取消完成标记。"
                    // Save data after successful modification
                    IF data_storage.save_tasks(task_manager.get_tasks()) THEN
                        PRINT "数据已保存。"
                    ELSE
                        PRINT "数据保存失败！"
                    END_IF
                ELSE
                    PRINT "错误：未找到ID为 " + task_id + " 的任务。"
                END_IF
            ELSE
                PRINT "错误：'undone' 命令需要有效的任务ID（数字）。"
            END_IF
        ELSE
            PRINT "错误：'undone' 命令需要一个任务ID。"
        END_IF

    ELSE IF command_type == "delete" THEN
        IF SIZE OF command_args == 1 THEN
            VAR task_id_string: STRING = command_args[0]
            VAR task_id: INTEGER
             IF IS_INTEGER(task_id_string) THEN
                task_id = PARSE_INTEGER(task_id_string)
                IF task_manager.delete_task(task_id) THEN
                    PRINT "任务 " + task_id + " 已删除。"
                    // Save data after successful modification
                    IF data_storage.save_tasks(task_manager.get_tasks()) THEN
                        PRINT "数据已保存。"
                    ELSE
                        PRINT "数据保存失败！"
                    END_IF
                ELSE
                    PRINT "错误：未找到ID为 " + task_id + " 的任务。"
                END_IF
             ELSE
                PRINT "错误：'delete' 命令需要有效的任务ID（数字）。"
             END_IF
        ELSE
            PRINT "错误：'delete' 命令需要一个任务ID。"
        END_IF

    ELSE IF command_type == "exit" THEN
        PRINT "退出应用。"
        RETURN FALSE // Indicate that the program should exit

    ELSE
        PRINT "未知命令:" + command_type
        PRINT "可用命令: add <描述>, list, done <ID>, undone <ID>, delete <ID>, exit"
    END_IF

    RETURN TRUE // Indicate that the program should continue running the loop
END_FUNCTION


// --- Main Program Execution Flow ---
PROGRAM_START

    // 1. Define the data file path. (Already done with DATA_FILE_PATH variable)

    // 2. Create DataStorage instance, link data file path.
    data_storage = NEW DataStorage(DATA_FILE_PATH)

    // 3. Call DataStorage's load function to read historical task data.
    VAR loaded_tasks: LIST OF Task = data_storage.load_tasks()

    // 4. Create TaskManager instance, pass the loaded task list.
    task_manager = NEW TaskManager(loaded_tasks)

    // 5. Enter the main loop, waiting for user input.
    VAR keep_running: BOOLEAN = TRUE
    LOOP WHILE keep_running == TRUE
        // 1. Prompt user for command.
        PRINT "\n请输入命令 (add, list, done, undone, delete, exit): "

        // 2. Read user input.
        VAR user_input: STRING = READ INPUT LINE

        // 3-7. Parse command, call logic, print feedback, save data if needed.
        // process_command handles logic execution, saving, and returns FALSE if exit is requested.
        keep_running = process_command(user_input)
    END_LOOP

    // Application exit flow:
    // 1. Call DataStorage's save function one last time before exiting.
    //    (This is already handled within process_command for successful modifications,
    //     but an explicit final save could be added here if desired, though redundant with current logic).
    //    Let's add a final save attempt just in case the loop exits by means other than the 'exit' command.
    PRINT "执行最终数据保存..."
    IF data_storage.save_tasks(task_manager.get_tasks()) THEN
        PRINT "数据保存成功。"
    ELSE
        PRINT "数据保存失败！"
    END_IF

    // 2. Print exit message. (Already done in process_command for 'exit' command)
    // 3. Program termination handled by loop exit.

PROGRAM_END
```