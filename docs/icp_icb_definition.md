# ICB - Intent Code Behavior 半自然语言行为描述层语法约定文档

## 前言

总文本量：约6000字，阅读需要约5-10分钟

`.icb` 文件是 ICP 协议中行为描述层的核心载体。它位于自然语言需求层 (`requirements.md`) 和真实代码之间。本层的核心目的是将高层的自然语言需求进行结构化的拆解，具象化软件的框架、运行流程、模块定义以及核心业务逻辑的处理方式。它侧重于描述“如何通过一系列步骤和行为来实现”特定功能，并在此层级初步勾勒出关键框架，如函数、类，等。`.icb`为后续目标代码的生成奠定基础

一个 `.icb` 文件通常代表一个模块或一个独立的功能单元。文件所在的目录结构对应于项目的模块结构，与 `src_target` 目录下的结构应当始终保持一致

`.icb` 文件允许使用中文/英文作为描述性文本。理论上来说，对其它语言的支持程度仅取决于大模型的训练结果

## 1. 行为/功能描述

在 `.icb` 层，我们使用 `func` 关键字声明一个新的功能或行为块。通常与 `func` 相伴随出现的内容还有：`input`, `output`, `behavior`

语法:

`func <功能名称>:`

`<功能名称>` 是一个标识符，应清晰地表达该功能的目的。命名推荐使用驼峰命名法 (camelCase) 或下划线命名法 (snake_case)。也可以使用描述性命名（如下方关于计算总价的示例），icp-toolchain 会结合描述内容尝试生成一个实际的可被调用的符号

语法:

`input: <参数列表>`
`output: <参数列表>`

描述输入参数，输出参数（返回参数），参数列表用逗号 `,` 分隔

语法:

`behavior:`
    `<描述步骤 1>`
    `<描述步骤 2>`
    `...`

`behavior:` 关键字开始一个功能或行为的具体描述块。该关键字之后的内容需要缩进

目前不允许在行为描述代码块中进行其它元操作，包括但不限于正则表达式、变量替换、字符串模板，等

### 示例1

```icb
func 计算总价:
input: 商品列表, 优惠码
output: 总金额, 应用的折扣
behavior:
    初始化一个变量来存储当前的总金额，初始值为零
    遍历商品列表中的每一个商品:
        对于每个商品，获取其价格，并累加到总金额变量中
        检查是否提供了优惠码
        如果提供了优惠码: 计算应用的折扣并更新总金额
    返回最终的总金额和应用的折扣变量的值
```

## 2. 对变量的明确描述

在行为描述过程中，我们允许使用隐含过程变量的描述来隐式地调用变量，也提供了明确的强制定义规则。

在 `.icb` 层，通过`var` 关键字强制让工具链识别：此处有一个开发者明确定义的变量

`var` 定义之后可以跟随一个可选的 `:` ，随后对变量进行一些精简的描述，例如如何初始化，或者应该使用什么类型的变量

如果开发人员强烈希望自始至终保证对变量的强掌控，可以使用 `$` 来进行明确的变量调用

但对于ICP-toolchain来说，被明确指示过的变量（也包括input和output中的参数列表）都会自然地在随后的“语义分析-构建”过程中，被一个名为“建议器”的部件存储

“建议器”将会把被隐性调用的变量修改为对已定义变量的明确调用，理想情况下，开发人员无需分心关注此过程

备注：考虑到未来自动补全插件的支持问题，同时也考虑到工具链的性能/效率问题，关于变量和已定义符号的明确使用语法还有改善空间，未来可能会出现一定程度的改变

### 示例2

```icb
func 计算总价:
input: 商品列表, 优惠码
output: 总金额, 应用的折扣
behavior:
    var 当前总金额: 初始化为0
    遍历商品列表中的每一个商品:
        对于每个商品，获取其价格，并累加到总金额中
        检查是否提供了优惠码
        如果提供了优惠码: 计算应用的折扣并更新 $当前总金额
    返回最终的 $当前总金额 和应用的折扣
```

## 3. 类的描述

在 `.icb` 层，我们使用 `class` 关键字声明一个类。

在类定义中，我们通过可选的`inh`关键字来描述类的继承。

对于类的构造/初始化函数以及析构函数并不提供强制规定，由于ICP-toolchain本身是一个由llm驱动的工具链，它通常能够合理地解析目标语言风格的函数定义

类变量：直接在`class`代码块下声明和定义，建议在代码块的顶端进行

实例变量/成员变量：声明时应添加`self.`前缀，如：`self.myVar`

如果你希望进行类似python风格的动态变量管理，成员变量的声明和初始化可以在`__init__`方法中进行

如果你希望进行类似C++风格的明确变量管理，建议将`self.myVar` 等内容放在`class` 代码块的末尾，并在`__init__`中管理初始化过程

我们在此仅对`class`这一概念进行最最基本/原始的框架定义，具体的设计哲学仍然应当遵循你所期望的目标语言的设计哲学

### 示例3

```icb
class ConfigManager:
inh: BaseClass
    var instance_count: 实例计数器
    
    func __init__:
    behavior:
        var self.configPath: 字符串
        初始化configPath
        var self.configParam: 字典
        instance_count++

    func 加载配置:
    behavior:
        尝试读取 this.configPath 指向的配置文件
        将配置文件内容加载进self.configParam
        若成功: 返回 true
        否则: 返回 false

    func 获取参数:
    input: configKey
    output: configParam
    behavior:
        var tempConfigParam: 初始化为none
        从已加载配置中查找configKey，存入tempConfigParam
        返回tempConfigParam

    // var self.configPath: 字符串
    // 类 C++ 风格的成员变量定义

```

## 4. 控制流

### 4.1 条件判断

`.icb` 描述分支控制时，允许通过明确的关键字控制，或者通过隐含分支的自然语言控制

目前提供的关键字有：`if` `else if` `else`

使用隐含分支关系的自然语言时请注意配合缩进与`:`的使用，工具链会尝试将其转化为明确的`if-else结构`

即便你没有提供`:`符号以及缩进，以现在大语言模型的能力也完全可以生成有效的代码，但我们仍建议保持良好的代码结构化习惯

语法:
`if <条件描述> :`
    `<结果或步骤描述>`
`else:`
    `<结果或步骤描述>`

#### 示例4

```icb
behavior:
    检查用户权限
    if 权限足够执行此操作: 
        执行操作并记录日志
    else:
        返回权限不足错误
    
```

```icb
behavior:
    尝试读取 self.configPath 指向的配置文件
    将配置文件内容加载进self.configParam
    若成功: 返回 true
    否则: 返回 false
```

### 4.2 循环与迭代

`.icb` 描述循环/迭代逻辑时，允许通过特定的关键字控制，也允许通过隐含循环/迭代逻辑的自然语言控制

隐含地进行描述性表达“对集合中的每一个元素执行...”，或使用包括但不限于“遍历”、“对每个”、“循环处理”、“for each”等词语结合缩进和`:`符号表达迭代逻辑

与分支语句不同，icb不提供明确的循环/迭代关键字，这是因为现代编程语言中提供的风格特色各异的循环/迭代机制确实过于丰富，相对于分支逻辑而言，难以找到足够“兼收并蓄”的关键字描述

因此我们选择相信大模型的转化能力，让它自然判断你的编程逻辑需求

和分支结构的规定一样，我们始终要求你保持对`:`符号和结构化缩进的良好使用，这会让你的代码总是清晰易读，同时也有利于工具链后续的自动构建

语法:
`对列表中的每一个项:`
    `<对当前项执行的操作>`

#### 示例5

```icb
behavior:
    读取文件所有行到列表中，每一个项目是文件中的一行代码
    对列表中的每一项字符串:
        如果是人员注释行：跳过此行，不记录
        如果行不为空且不是注释行: 解析行的缩进量，并append进入结果变量
    返回结果变量

```

## 5. 注释

`.icb` 文件支持两种类型的注释 - 人员注释与意图注释。它们被用于不同的目的。

人员注释 (`//`):

常规的注释内容，主要面向代码阅读人员。icp-toolchain 会直接忽略此注释

意图注释 (`@`):

意图注释是icb的一个极端重要的组成成分，它会直接影响icb和不同类型编程语言的“元交互”，是icb与不同编程语言之间的特殊“沟通桥梁”

意图注释用于提供额外的，非行为流程内的元信息；抑或是未被icb直接定义，但在目标语言中有必要需求的特性

意图注释位于特定的关键字的“上方”，且单独占据一行，用以注释这个特定的关键字

当意图注释用于修饰某个“没有子代码块”的关键字时，意图注释仅作用于这个关键字上

比如，位于`input`关键字上方的意图注释就仅修饰输入参数表，位于`func`关键字上方的意图注释不修饰行为代码，而是修饰函数定义本身

当意图注释位于某个“有子代码块”的关键字上方，意图注释会作用于这个关键字以及这个代码块内的所有代码

比如，位于`behavior`关键字上方的意图注释，就会作用于这个代码块内的所有代码行

又如当意图注释作用于一个`if-else`时，意图注释就作用于这个`if-else`代码块内的所有代码

`class`关键字被认为是一个“有子代码块”的关键字，因此`class`上方的意图注释也同时会作用于这个`class`代码块内的所有代码行

比起抽象的概念定义，我们不如来看一些**直观的实际范例**

### 示例6

例a icb并未定义类的继承方式。如C++中的继承分为private, protected, public三种类型，因此这种额外信息就需要意图注释来进行处理。

```icb
// 如果是针对整个class的意图注释，则应该放这一行
class MyClass:
@ private继承
inh: BaseClass

    func myFunc:
        ...

```

例b 对变量传递方式的定义。不同编程语言对于直接传参、引用传参、乃至指针传参等操作的处理存在诸多差异。我们不希望定义晦涩难懂的传值语法，因此具体的变量传递应该由开发者借由意图注释来明确掌控

```icb
func myFunc:
@ 字符串列表是引用传递
input: 字符串列表, 新字符串
behavior:
    字符串列表.append(新字符串)

```

例c 定义函数“接口”。比如C++用纯虚函数来处理“接口”的概念，python高度动态且可以随时修改函数方法，JAVA直接支持interface关键字。开发者可以借助意图注释来定义“接口”，促使工具链进行相应的代码实现

```icb
@接口函数，要求派生类必须实现此函数
func someClassGetName:
output: 当前派生类的name
behavior:
    // 纯接口定义，无具体实现
    // 虽然此处无实际行为代码，但仍需注意意图注释不会作用于此

```

例d 当开发者的需求对整个代码块都起作用，不希望额外的多次描述。比如开发者希望约束某部分代码块的内存使用

```icb
func FIR滤波计算:
input 输入信号, 滤波器系数
output 输出信号
@ 函数行为中应该适时使用malloc动态内存分配
behavior:
    // 后续是具体函数实现
    ...

```

例e 对变量生命周期的显式声明

```icb
...
behavior:
    @ 生命周期 thread_local
    var myVar
    // 其实基本等价于 var myVar: 生命周期为thread_local. 此处更多是为了演示意图注释
    // 后续是其它代码，不受意图注释影响
    ...

```

除此之外的例子数不胜数，包括但不限于：泛型的处理、namespace的处理、变量的所有权，等。各类语言的多种多样的不同特性差异，浩如烟海，难以穷尽

我们希望开发者对此有强掌控力，却又不希望icb的语法变得”面目可憎“，因此定义了意图注释的概念，让开发者能够在得到工具链的灵活性的同时对代码行为具备强掌控力

同时，这也意味着icb**并不是**“真正的”自然语言编程，对icb的高效使用的前提条件是对目标编程语言的高度掌控

考虑到意图注释的极端灵活性，我们有必要对它做出额外约定限制：

1. 意图注释不应该超过30个汉字
2. 意图注释永远不能换行，也不允许连续多行意图注释
3. 意图注释不被允许在行为描述代码段中零碎使用，必须针对完整代码块（行为描述本身就是一种自我注释）
4. 不允许在意图注释中进行其它元操作，包括但不限于正则表达式、变量替换、字符串模板，等

特别备注：

作为intent code protocol的发起者，我很清楚**绝对的灵活性必然会导致绝对的滥用**。然而，在icp刚起步的现阶段，意图注释已是我目前可见的“局部最优解”

也许在未来，当icp的社区真的能够建设起来，我们能探索出更强大且合理的解决方案。针对不同的目标语言，也可能会出现不同的约定手册来指导意图注释的规范化使用，甚至由大量的常用意图注释催化出其它icb原生关键字

## 6. 对外符号描述

在 `.icb` 文件中，我们引入 `description` 关键字，用于为特定的函数、变量、类等符号提供简洁的功能、职责或作用描述。该描述应尽量简明扼要，避免超过50个汉字或30个英文单词

这一描述将作为符号的总结性说明，**它并不在当前关键字上进行直接作用**，而是一种对外声明，让工具链在处理依赖符号时，能进行更合理的函数/类/全局变量调用

此关键字并非强制性要求，不过当你在使用ICP-toolchain时，如果工具链始终难以正确地考虑函数调用等依赖项，可以考虑利用description关键字进行额外的描述

语法:
`description: <描述文本>`

说明:

- `description` 关键字出现在 `func`、`var` 或 `class` 声明之后，不允许出现额外空行，对于`func`而言必须处在 `input`、`output` `behavior` 几个关键字之前
- 每个符号（函数、变量、类）最多只能有一个 `description` 描述
- 描述文本应简洁且清晰地表明一个符号的对外功能，特别关注符号调用的“结果/功能”而不是内部运行细节
- 局部变量暂时不应该出现 `description` 关键字描述，较远的未来中可能会规划带有作用域定义的description关键字
- `description`不允许被意图注释修饰，此行为无意义。

### 示例8

对函数使用:

```icb
func 计算总价:
description: 
    根据商品列表和优惠码计算最终总价和折扣
    只有在用户使用优惠码时才需要调用    // 准确来讲换行应该被避免，此处仅作为演示
input: 商品列表, 优惠码
output: 总金额, 应用的折扣
behavior:
    ...
```

对变量使用（用于对外可见的变量）:

```icb
class ConfigManager:
    var configPath: 字符串
    description: 存储配置文件的路径字符串

    func 加载配置
    behavior:
    ...
```

对类使用:

```icb
class ConfigManager:
description: 负责配置文件的加载和参数读取
    ...
```

## 7. 模块引用

`import`是一个用于描述模块引用的关键字，它对应着各类编程语言的文件调用功能，比如C++的头文件，又或者python的import语句。

语法:
`import: <模块名>`

虽然ICP-toolchain不会进行强制限制，但`import`关键字只应该出现在每个文件的最上方

`import`关键字随后跟随的是一个单独的文件名，也可以带有具体的路径

```icb
import: IcbAnalyzer
...

```

## 8. 关于缩进

缩进在 `.icb` 文件中具有结构性意义，用于表示行为块的范围以及逻辑控制流的嵌套层级。必须使用一致的缩进单位，例如4个空格

具体缩进数量在icb_config.json中设置，默认为4；不允许使用tab；不建议使用其它缩进空格数量，个别特殊情况考虑使用2空格缩进

input, output, behavior几个关键字是固定跟随在func后的，icb规定这几个固定位置的关键字直接和func关键字保持平齐

特别备注：

仍然是来自ICP发起者的留言 ——

是的，现代编程语言除了python几乎没有别的强制以缩进处理代码块的例子。且进一步说，python的这种做法也为它带来了持续的争议（甚至激烈的批评）

但 —— 还是那句话，**ICP不是一门编程语言，而是一种描述约定**

icb自身已经带有足够多的“模糊性”，真的没必要再用`{}`来强调代码块的“精确性”。特别的，对于中文来说，去除`{}`符号能带来的**更加自然语言式**的阅读和书写体验一定是利大于弊的

更何况，整个ICP都是由LLM来驱动的，在大模型能力越来越强的未来，`{}`符号的缺失并不会对LLM带来什么阻碍

甚至 —— ICP-toolchain可能也会很快被淘汰，我们会把icb文件丢进某个agent让它自动处理（但这不会是我不去设计制作ICP-toolchain的理由，它在当下有非常的必要性）

## 9. 其它内容

目前icb没有定义在behavior块之外独立作用的行为代码，比如`.py`或`.sh`的简单脚本文件就经常会有这种直接在文件行内顺序运行的代码

当前理由有两点：

1. 方便初期ICP-toolchain的快速实现，尽量减少功能特性也能减少bug
2. icb一定程度上是为了完整的工程项目而设计，简单的脚本语法完全可以直接通过和大模型对话来快速获取

## 完整示例

```icb
// config_manager.icb
// 配置管理模块，负责配置文件的加载和参数读取

@ 此模块为系统核心组件，需始终确保线程安全
class ConfigManager:
description: 负责管理应用程序配置的加载和参数读取
inh: BaseClass

    var configPath: 字符串
    description: 配置文件路径

    var configData: 字典
    description: 存储加载后的配置数据

    func 加载配置:
    description: 加载配置文件内容到内存
    input:
    output: 布尔值
    behavior:
        // 尝试读取配置文件
        try 打开并读取 this.configPath 指向的文件内容
        if 打开文件 fails:
            记录错误："无法打开配置文件"
            返回 false
        @ 配置文件格式为 JSON
        else:
            try 解析文件内容
            if 解析 fails:
                记录错误："配置文件格式错误"
                返回 false
            else:
                将解析后的对象存入 this.configData
                返回 true

    func 获取参数:
    description: 根据参数名获取配置值
    input: 参数名: 字符串
    output: 字符串
    behavior:
        // 检查配置是否已加载
        if this.configData 为空:
            调用 this.加载配置()  // 尝试自动加载配置
            if 加载失败:
                返回 "配置未加载"

        // 查找参数值
        if 参数名 存在于 this.configData 中:
            返回 this.configData[参数名]
        else:
            记录警告："配置参数不存在：" + 参数名
            返回 ""

    func 设置参数:
    description: 更新配置参数值
    input: 参数名: 字符串, 参数值: 字符串
    output: 布尔值
    behavior:
        if this.configData 为空:
            调用 this.加载配置()
            if 加载失败:
                返回 false

        // 更新参数值
        this.configData[参数名] = 参数值
        返回 true

    func 保存配置:
    description: 将配置保存回文件
    input:
    output: 布尔值
    behavior:
        if this.configData 为空:
            返回 false

        try 打开 this.configPath 指向的文件进行写入
        if 打开文件 fails:
            记录错误："无法写入配置文件"
            返回 false
        else:
            将 this.configData 序列化为JSON字符串
            将JSON字符串写入文件
            关闭文件
            返回 true


@ 函数仅在此文件直接被运行时会起作用
func 作为main时初始化系统配置:
input:
output: 布尔值
behavior:
    var 配置管理器 = new ConfigManager()
    配置管理器.configPath = "config/app_settings.json"

    if 配置管理器.加载配置() == false:
        记录错误："系统配置加载失败"
        返回 false
    else:
        var 服务端口 = 配置管理器.获取参数("server_port")
        if 服务端口 == "":
            配置管理器.设置参数("server_port", "8080")
            配置管理器.保存配置()

        返回 true

```
