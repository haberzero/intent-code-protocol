# ICP (Intent Code Protocol) 文档

## 1. ICP 简介与核心理念

构想中的一种半自然语言编程描述系统，目前，我将其命名为 ICP: Intent Code Protocol。这事实上不是一门新的编程语言，且永远都不应该成为一种可以直接“运行”或者“编译”的编程语言。

核心理念:

* 超级中间件: 它应当是一种让大语言模型能够和实际编程语言进行“精确化、可信化、可控化沟通”的约定，是一种伪代码形式的提示词协议，是一种沟通传统编程语言和大模型的超级中间件。
* 稳定可控与精细修改: 更通俗地来讲，它应该能让大模型生成的代码变得稳定可控，且允许开发人员进行精细化修改、在多个抽象层次修改，并关联影响到其它层级的内容。
* 快速演进: 这个协议自诞生之初就注定了它的快速演进性质，它永远都会跟随大模型本身的进化而快速地演进，任何被彻底定义的语法结构都会导致其丧失快速迭代进化的能力。

ICP 是在大模型时代下对传统软件开发哲学的具象化拆解重构。它“几乎就是”一门编程语言，一门针对现代大模型构建的提示词协议。

## 2. ICP 的基本结构 - 三个抽象层级

ICP 包含三个核心抽象层级，由高到低分别是：自然语言提示词层，半自然语言行为描述层，代码层。这三个层级共同构成了从人类需求到接近可执行代码的逐级细化路径。

### i. 自然语言提示词层

自然语言提示词层就是人类之间相互沟通、人类和语言模型进行直接沟通的最基本自然的口语化语法。对于 ICP 而言，本层指代了对“软件需求/编程需求”的直接口语化描述。

这是用户与 ICP 系统交互的起点，用户以自由的自然语言表达他们的编程意图和需求。

简单示例:

* `创建一个计算两个数字之和的 Python 函数。`
* `帮我写一个读取配置文件的类，并提供获取配置项的方法。`

### ii. 半自然语言行为描述层

半自然语言行为描述层是对自然语言提示词层的具象化需求拆解。在此层级，最初的软件框架将会形成，使用不带有偏见、情绪的，带有基本合理编程思想的客观化表达，作为代码基本功能单元的描述。本层级暂时不强制定义语法规则，但应当能看出类似编程代码的内容结构，包括但不限于合理的缩进、对特定具体符号的调用、对特定关键变量的定义、对代码块的分割，等。

应当允许使用中文/英文进行构建，遥远的未来可能会尝试适配多种语言。

核心构建内容:

* 项目文件夹的结构
* 软件的基本构成框架
* 软件的运行流程描述
* 软件中的类、函数、变量定义
* 业务分支逻辑的处理方式

所有这些内容，都是对软件结构的实际行为描述。在构建此层级时，代码的关键符号表将会被生成，包括但不限于关键的全局变量、全局单例等符号会被精确描述，防止模型幻觉带来的调用不存在的函数/变量/实例等问题。

我们可以用一种不完全准确的形容：半自然语言行为描述层就像是一种对于软件源代码的完备注释。在与大模型的首次几轮的需求对话结束后，开发人员应该花费超过总工程一半的时间在半自然语言行为描述层进行进一步开发。

注: 为了方便起见，本层级在后续内容将被称为行为描述层。

行为描述层概念示例:

```behaviorcode

等待填充

```

### iii. 真实代码层

真实代码层是半自然语言行为描述层所生成的代码，可经过对应语言的编译器/解释器处理后得到真正的可执行代码

## 3. ICP 具备的基本功能/特征

### i. 工程配置文件

ICP 包含一个工程配置文件。

用途: 描述当前 ICP 工程构建所需的关键外部依赖和环境信息，确保协作的一致性和构建的可预测性。

文件内容包括但不限于:

* 当前 ICP 工程调用的具体大模型
* 当前 ICP 工程最终所能生成的具体编程语言
* 当前 ICP 需要调用的功能库/源代码库

概念性 `icp_config.json` 示例结构:

```json
{
    "projectName": "basic_statistics_app",
    "icpVersion": "0.0.2",
    "targetLanguage": "Python",
    "api-url": "",
    "api-key": "",
    "llmModel": "qwen3-8b-instruct",
    "dependentLib": [
        "numpy",
        "scipy"
    ],
    "buildSettings": {
        "installCommand": ""
    },
    "fileSystemMapping": {
        "behavioralLayerDir": "src_mbh/",
        "symbolicLayerDir": "src_mpc/",
        "targetLayerDir": "src_target/",
        "is_extra_suffix": true
    },
    "fileSpecificSettings":{}
}
```

### ii. 符号表

符号表是贯穿整个 ICP 工程的 `json` 文件。它是行为描述层最终代码生成之间进行精确沟通和依赖检查的核心。

特征:

* 全局性: 符号表在行为描述层构建的过程中应该始终被参考/修改完善。
* 初步构建: 生成行为描述层之后应该生成一个初步的符号表。
* 持续迭代: 在后续开发人员进行反复迭代的过程中，符号表会逐渐趋于完整，并且逐渐将 ICP 工程中所有可能涉及到的符号内容都存储起来。
* 依赖存储: 除了符号本身，符号表中还会存储一些文件之间的依赖关系（`depend_content`），供代码生成过程参考使用。
* 工具链主导更新: 符号表不应该被开发人员过多地手动修改。我们应该尽可能多地借助大模型以及ICP-Toolchain 的能力对符号表进行更新，审查才是重点，手动修改不应该成为重点。

符号表示例结构:

```json
{
    "depend_content": {
        "file1": {
            "file2": [
                "global_var3"
            ]
        }
    },
    "dir_content": {
        "file1": {
            "function1": "bottom",
            "ClassA": {
                "method1": "bottom",
                "method2": {
                    "local_var1": "bottom",
                    "local_var2": "bottom"
                },
                "class_variable1": "bottom"
            },
            "global_var1": "bottom",
            "file_level_variable": "bottom"
        },
        "file2": {
            "global_var3": "bottom"
        }
    },
    "symbols_param": {
        "file1.function1": {
            "type": "func",
            "scope": "file",
            "description": "This function does something important."
        },
        "file1.ClassA": {
            "type": "class",
            "scope": "file"
        },
        "file1.ClassA.method2.local_var1": {
            "type": "var",
            "scope": "method",
            "is_frozen": false
        },
        "file1.ClassA.class_variable1": {
            "type": "var",
            "scope": "class",
            "is_frozen": true
        },
        "file1.file_level_variable": {
            "type": "var",
            "scope": "file"
        },
        "file1.global_var1": {
            "type": "var",
            "scope": "global",
            "description": "A global variable used throughout the file.",
            "is_frozen": false
        }
    },
    "ignore_list": [
        "path/to/ignored_file1",
        "path/to/ignored_dir"
    ],
    "frozen_list": [
        "path/to/frozen_file1",
        "path/to/frozen_dir"
    ]
}
```

这个结构清晰地展示了符号的作用域（全局、文件、类、函数）以及文件间的依赖关系，为大模型生成具有正确符号引用和依赖的代码提供了精确的指导。

### iv. 提示词注释

* 人员注释 `//`: 完全是给人看的，不会影响模型行为或最终代码生成逻辑。
* 模型注释 `@`: 用于向模型传递额外的、不适合放在行为描述主体中的指令或约束。例如，指定特定算法、性能要求、安全考虑等。

范例:

```text
class MyDataStructure:
    // 这只是一段给后来者看的玩笑性注释
    @ 此处必须使用双向链表进行实现
    def process_elements():
        pass
```

### v. 宏定义 (暂定)

宏定义，即 `#` 开头定义的符号在构建过程中会被替换为实际的代码或文本内容。提示词注释的 `#define` 形式就是宏定义的一种表现形式。

引入原因:

* ICP 的最初定义者（是的就是我）在定义 ICP 时主要是一个嵌入式 C++ 程序员，认为宏定义对于 ICP 而言有很大可能是一种必需品，我清楚地知道宏定义这一特性在现代编程语言中的争议性，没有任何理由，对此特性的初期定义仅仅出于一种强烈的直觉。
* ICP 本质上是一种约定、一个提示词协议，不是真正的编程语言，可以在未来弃用该特性，只需将历史版本的宏定义直接替换为实际文字即可。

引入限制:

为了避免宏定义这一概念的滥用，必须做出以下限制（部分限制在未来可能成为强制性的）：

* a. 内容行数限制: 宏定义的内容*不应该*超过 7 行，除开大括号 `{}` 所占据的行以外，实际具备含义的宏定义内容不应该超过 5 行。这不是一个强制限制，而是超过 80% 情况下应遵守的约定。
* b. 嵌套深度限制: 宏定义的嵌套*不能*大于 3 次。这在未来应当会成为一个强制性的限制。超过 3 层的宏定义嵌套应该导致 ICP 的构建器报错警告并停止运行。这是为了避免复杂的、难以理解的嵌套结构。
* c. 用途限制: 宏定义*不是*拿来定义变量的，也*不是*拿来定义配置的。对于 C/C++ 程序员而言，请不要写出 `#define mian main` 之类的操作。宏定义用于定义变量或配置会导致陷入“过分具体的代码”中，并可能导致文件间的强依赖。请善用工程配置文件（用于配置）和符号表（用于变量/符号定义和管理）。
* d. 文件间传递限制: 宏定义*不应该*在过多文件之间传递，且传递层级*不应该*超过3层；宏定义*不能*在超过2个文件间出现嵌套。

宏定义概念示例:

考虑一个常见的代码模式，如安全地获取字典中的值并提供默认值。这可能在行为描述层被描述为：

```text
在字典 safe_get_value(my_dict, key, default_value) 中安全获取 key 对应的值，若 key 不存在则返回 default_value。
```

假设这是一个常用的模式，可以定义一个宏：

```text
#define SAFE_DICT_GET(dict, key, default):
{
    @ 请生成安全获取字典值的代码，使用 .get() 方法。
    get_value_safely(dict, key, default):
        return dict.get(key, default)
}
```

然后在行为描述层中使用：

```text
// 文件: utils.py
# SAFE_DICT_GET

// 在 ConfigReader 中使用这个模式来读取配置
class ConfigReader:
    def read_config():
        // ... (rest of the function) ...
        config_data = parse_json(file_content)
        log_level = safe_get_value(config_data, "log_level", "INFO")
        // ... (rest of the function) ...
```

### vi. 反向构建过程（处于规划中）

反向构建是将现有历史代码适配到 ICP 框架的过程。这一功能是 ICP 期望成为通用中间件的关键组成部分，其目标在于将庞大的现有历史代码纳入 ICP 的统一框架中。这能最大限度地利用已有的工程/源码，也有利于大量企业最大限度地发挥 ICP 的功能，为自己的历史工程插上大模型的翅膀。

这一过程同样应该由大模型进行。

## 4. 其它补充

### ICP 构建哲学

* ICP 将传统开发过程中的“需求分析”、“概要设计”、“详细设计”等阶段，映射到了“自然语言提示词层”、“行为描述层”、“实际代码”这三个明确的抽象层级，并且试图通过引入分布式符号表的概念来对大模型的生成行为做出强规范。
* ICP 自诞生之初就注定了它的快速演进性质。它不是一门需要固定语法进行编译的编程语言，而是一种协议和约定。
* ICP 会跟随大模型本身的进化而快速地演进。任何被彻底定义的、僵化的语法结构都会导致其丧失快速迭代进化的能力。这种灵活性使其能够适应未来大模型能力的飞速提升。
