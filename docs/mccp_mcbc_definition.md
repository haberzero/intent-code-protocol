# MCCP 半自然语言行为描述层语法约定文档

## 前言

`.mcbc` 文件是 MCCP 协议中行为描述层的核心载体。它位于自然语言需求层 (`requirements.md`) 和符号-伪代码层 (`.mcpc`) 之间。本层的核心目的是将高层的自然语言需求进行结构化的拆解，具象化软件的框架、运行流程、模块定义以及核心业务逻辑的处理方式。它侧重于描述“如何通过一系列步骤和行为来实现”特定功能，并在此层级初步勾勒出关键符号（函数、流程块等）的框架，同时也描述软件中将要存在的变量和类等概念，为后续 `.mcpc` 层和目标代码层的生成奠定基础。

一个 `.mcbc` 文件通常代表一个模块或一个独立的功能单元。文件所在的目录结构对应于项目的模块结构，与 `.mcpc` 和 `src_target` 目录下的结构应当始终保持一致。

`.mcbc` 文件允许使用中文/英文作为描述性文本。理论上来说，对其它语言的支持程度仅取决于大模型的训练结果。

## 1. 行为/功能描述

在 `.mcbc` 层，我们使用 `func` 关键字声明一个新的功能或行为块。通常与 `func` 相伴随出现的内容还有：`input`, `output`, `behavior`。

语法:  
`func <功能名称>:`  
`<功能名称>` 是一个标识符，应清晰地表达该功能的目的。命名推荐使用驼峰命名法 (camelCase) 或下划线命名法 (snake_case)。也可以使用描述性命名（如下方关于计算总计的示例），mccp-toolchain 会结合描述内容尝试生成一个实际的可被调用的符号。

语法:  
`input: <参数列表>`  
`output: <参数列表>`  

描述输入参数，输出参数（返回参数），参数列表用逗号 `,` 分隔。

语法:  
`behavior:`      
    `  <描述步骤 1>`
    `  <描述步骤 2>`
    `  ...`

`behavior:` 关键字开始一个功能或行为的具体描述块。该关键字之后的内容需要缩进。

### 示例：

```mcbc
func 计算总价:
input: 商品列表, 优惠码
output: 总金额, 应用的折扣
behavior:
    初始化一个变量来存储当前的总金额，初始值为零。
    遍历商品列表中的每一个商品。
    对于每个商品，获取其价格，并累加到总金额变量中。
    检查是否提供了优惠码。
    如果提供了优惠码，计算应用的折扣并更新总金额。
    返回最终的总金额和应用的折扣变量的值。
```

## 2. 变量和类概念描述

在 `.mcbc` 层，我们通过语言文本配合结构化缩进语法对变量 (`var`) 和类 (`class`) 的功能职责进行描述。

准确来说，在行为描述层允许使用隐含过程变量的描述来对过程中出现的变量进行说明，`var` 关键字的主要使用目的是强制让大模型识别：此处有一个开发者强制要求的变量。

`var` 定义之后可以跟随一个`:`，随后对变量进行一些精简的描述，例如如何初始化，或者应该使用什么类型的变量。

### 示例 (过程变量的描述)

```mcbc
func 计算总价:
input: 商品列表, 优惠码
output: 总金额, 应用的折扣
behavior:
    var 当前总金额: 初始化为0。
    遍历商品列表中的每一个商品。
    对于每个商品，获取其价格，并累加到总金额变量中。
    检查是否提供了优惠码。
    如果提供了优惠码，计算应用的折扣并更新 var 当前总金额。 
    返回最终的 var 当前总金额 和应用的折扣变量的值。 
```

### 示例 (类的描述)

```mcbc
class ConfigManager:
    var configPath: 字符串
    
    func 加载配置
    behavior:
        尝试读取 this.configPath 指向的配置文件
        若成功则返回 true
        否则返回 false
    
    func 获取参数
    behavior:
        从已加载配置中查找指定参数名
        返回对应的参数值
```

## 3. 逻辑控制流

`.mcbc` 层支持描述控制流，但不强制要求使用精确的 `if-else` 语法。开发者可以使用隐含分支结构或隐含循环结构的自然语言说明，但是应当注意合理缩进，便于大模型的识别。

### 3.1 条件判断

语法:
`if <条件描述> :`
    `<结果或步骤描述>`
`else:`
    `<结果或步骤描述>`

#### 示例:

```mcbc
behavior:
    检查用户权限。
    if 权限足够执行此操作  执行操作并记录日志。
    else:
        返回权限不足错误。
```

### 3.2 循环与迭代

`.mcbc` 层通过描述性语句结合缩进说明循环或迭代行为。可以提供特定的循环关键字（如 `for`, `while`），也可以隐含地进行描述性表达“对集合中的每一个元素执行...”。

语法:  
`<描述性语句，隐含迭代需求，如：> 对列表中的每一个项:`
    `  <对当前项执行的操作>`

说明: 使用如“遍历”、“对每个”、“循环处理”、“for each”等词语结合缩进表达迭代逻辑。

#### 示例:

```mcbc
behavior:
    读取文件所有行到列表中。
    对列表中的每一行:
        如果是注释行：跳过此行，不记录
        如果行不为空且不是注释行: 将内容append进入结果变量
    返回结果变量

```

### 3.3 错误处理与尝试

使用 `try...` 结构描述可能失败的操作，并结合 `if fails ...` 描述失败时的处理。

对于不支持类似 try-catch 语法的目标语言而言，此类操作应当被转化为基本的分支语句。

语法:  
`try <操作描述>`

`if <操作描述> fails <失败处理描述>`

#### 示例:

```mcbc
behavior:
    try 连接到数据库
    if 连接到数据库 fails  记录错误日志并终止操作。
    else:
        执行数据库查询。
        处理查询结果。
```

## 4. 注释

`.mcbc` 文件支持两种类型的注释，用于不同的目的：

人员注释 (`//`): 常规的注释内容，主要面向代码阅读人员。mccp-toolchain 会直接忽略此注释。

意图注释 (`@`): 用于提供额外的、非行为流程内的元信息，例如对代码行为的额外约束、性能要求、安全考虑、线程约束等。这些注释旨在对模型的理解和生成过程进行额外约束。

- 当用户有一些不便于或不希望被包含在行为描述流程中的内容时，可以使用此意图注释。mccp-toolchain会对此类意图注释进行特定处理。
- 意图注释的作用域是**其下方的代码块**，例如，在func前的意图注释会影响整个func的behavior，在分支块内的意图注释**应该和分支关键字本身平齐**，暗示意图注释的作用域是下方整个分支代码块。
- 意图注释不应该被零散地使用，零散的意图注释实际上就是一种行为描述代码，大量混在行为描述代码中的 `@` 标识符只会造成混淆，请勿滥用

#### 示例:

```mcbc
// 这个函数会进行系统的初始化，这段人员注释会被 mccp-toolchain 忽略
@ 这个模块是高性能关键路径的一部分，模型生成代码时需要考虑效率。优先考虑运行时间短的算法，无需考虑空间占用。可以使用标准库的读取函数
func 初始化系统:
input: 配置文件路径
output: 成功状态, 错误信息字符串
behavior:
    try 读取配置文件。 
    if 读取配置文件 fails 返回错误状态和信息。
    else:
    @ 配置格式是 YAML，需要使用特定的解析库。
        解析配置内容。
        根据配置内容 初始化各个模块。
        返回成功状态。
```

## 5. 对外符号描述

在 `.mcbc` 文件中，我们引入 `description` 关键字，用于为特定的函数、变量、类等符号提供简洁的功能、职责或作用描述。该描述应尽量简明扼要，不超过50个汉字或30个英文单词。

这一描述将作为符号的总结性说明，它并不在当前文件中进行作用，而是一种对外声明，用于后续大模型在处理依赖符号时，能进行合理的函数/类/全局变量调用。

此关键字并非强制性要求，不过当你在使用MCCP-toolchain时，如果你的模型始终难以正确地考虑函数调用等依赖项，可以考虑利用description关键字进行额外的描述。

语法:
`description: <描述文本>`

说明:
- `description` 关键字可以出现在 `func`、`var` 或 `class` 声明之后，但在 `input`、`output` 或 `behavior` 之前
- 每个符号（函数、变量、类）最多只能有一个 `description` 描述
- 描述文本应简洁且清晰地表明一个符号的对外功能，特别关注符号调用的“结果/功能”而不是内部运行细节。
- 局部变量原则上不应该出现 `description` 关键字描述，较远的未来中可能会规划带有作用域定义的description关键字。

### 示例:

在函数中使用:
```mcbc
func 计算总价:
description: 根据商品列表和优惠码计算最终总价和折扣
input: 商品列表, 优惠码
output: 总金额, 应用的折扣
behavior:
    ...
```

在变量中使用（必须用于对外可见的变量）:
```mcbc
class ConfigManager:
    var configPath: 字符串
    description: 存储配置文件的路径字符串

    func 加载配置
    behavior:
        ...
```

在类中使用:
```mcbc
class ConfigManager:
description: 负责配置文件的加载和参数读取
    var configPath: 字符串
    ...
```

## 6. 缩进约定 (indentation convention)

缩进在 `.mcbc` 文件中具有结构性意义，用于表示行为块的范围以及逻辑控制流的嵌套层级。建议使用一致的缩进单位（例如，4个空格）。

input, output, behavior几个关键字是固定跟随在func后的。出于减少缩进数量的考虑，规定这几个固定位置的关键字直接和func关键字保持平齐

### 示例:

```mcbc
func 处理订单:
input: 订单数据
output: 处理结果
behavior:
    验证订单数据的完整性。
    if 验证失败:
        记录验证失败日志。
        打印失败信息。
        返回失败原因代码。
    else:
        检查库存。
        if 库存充足:
            扣减库存。
            生成支付请求。
            返回支付请求信息。
        else:
            标记订单为缺货。
            通知用户。
            返回缺货信息。
```

## 完整示例

```
// config_manager.mcbc
// 配置管理模块，负责配置文件的加载和参数读取

@ 此模块为系统核心组件，需始终确保线程安全
class ConfigManager:
description: 负责管理应用程序配置的加载和参数读取
    var configPath: 字符串
    description: 配置文件路径
    
    var configData: 字典
    description: 存储加载后的配置数据

    func 加载配置:
    description: 加载配置文件内容到内存
    input: 
    output: 布尔值
    behavior:
        // 尝试读取配置文件
        try 打开并读取 this.configPath 指向的文件内容
        if 打开文件 fails:
            记录错误："无法打开配置文件"
            返回 false
        else:
        @ 配置文件格式为 JSON
            try 解析文件内容
            if 解析 fails:
                记录错误："配置文件格式错误"
                返回 false
            else:
                将解析后的JSON对象存入 this.configData
                返回 true

    func 获取参数:
    description: 根据参数名获取配置值
    input: 参数名: 字符串
    output: 字符串
    behavior:
        // 检查配置是否已加载
        if this.configData 为空:
            调用 this.加载配置()  // 尝试自动加载配置
            if 加载失败:
                返回 "配置未加载"
        
        // 查找参数值
        if 参数名 存在于 this.configData 中:
            返回 this.configData[参数名]
        else:
            记录警告："配置参数不存在：" + 参数名
            返回 ""

    func 设置参数:
    description: 更新配置参数值
    input: 参数名: 字符串, 参数值: 字符串
    output: 布尔值
    behavior:
        if this.configData 为空:
            调用 this.加载配置()
            if 加载失败:
                返回 false
        
        // 更新参数值
        this.configData[参数名] = 参数值
        返回 true

    func 保存配置:
    description: 将配置保存回文件
    input: 
    output: 布尔值
    behavior:
        if this.configData 为空:
            返回 false
        
        try 打开 this.configPath 指向的文件进行写入
        if 打开文件 fails:
            记录错误："无法写入配置文件"
            返回 false
        else:
        @ 使用 JSON 格式保存
            将 this.configData 序列化为JSON字符串
            将JSON字符串写入文件
            关闭文件
            返回 true


@ 这段代码是使用示例，在最终结果代码中必须全部注释，仅作为参考或者在功能测试时临时使用
func 初始化系统配置:
input: 
output: 布尔值
behavior:
    var 配置管理器 = new ConfigManager()
    配置管理器.configPath = "config/app_settings.json"
    
    if 配置管理器.加载配置() == false:
        记录错误："系统配置加载失败"
        返回 false
    else:
        var 服务端口 = 配置管理器.获取参数("server_port")
        if 服务端口 == "":
            配置管理器.设置参数("server_port", "8080")
            配置管理器.保存配置()
        
        返回 true

```
