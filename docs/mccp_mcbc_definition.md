# MCCP 半自然语言行为描述层语法约定文档

## 前言

`.mcbc` 文件是 MCCP 协议中行为描述层的核心载体。它位于自然语言需求层 (`requirements.md`) 和符号-伪代码层 (`.mcpc`) 之间。本层的核心目的是将高层的自然语言需求进行结构化的拆解，具象化软件的框架、运行流程、模块定义以及核心业务逻辑的处理方式。它侧重于描述“如何通过一系列步骤和行为来实现”特定功能，并在此层级初步勾勒出关键符号（函数、流程块等）的框架，同时也描述软件中将要存在的变量和类等概念，为后续 `.mcpc` 层和目标代码层的生成奠定基础

一个 `.mcbc` 文件通常代表一个模块或一个独立的功能单元。文件所在的目录结构对应于项目的模块结构，与 `.mcpc` 和 `src_target` 目录下的结构应当始终保持一致

`.mcbc` 文件允许使用中文/英文作为描述性文本。理论上来说，对其它语言的支持程度仅取决于大模型的训练结果

## 1. 行为/功能描述

在 `.mcbc` 层，我们使用 `func` 关键字声明一个新的功能或行为块。通常与 `func` 相伴随出现的内容还有：`input`, `output`, `behavior`

语法:

`func <功能名称>:`

`<功能名称>` 是一个标识符，应清晰地表达该功能的目的。命名推荐使用驼峰命名法 (camelCase) 或下划线命名法 (snake_case)。也可以使用描述性命名（如下方关于计算总价的示例），mccp-toolchain 会结合描述内容尝试生成一个实际的可被调用的符号

语法:

`input: <参数列表>`
`output: <参数列表>`

描述输入参数，输出参数（返回参数），参数列表用逗号 `,` 分隔

语法:

`behavior:`
    `  <描述步骤 1>`
    `  <描述步骤 2>`
    `  ...`

`behavior:` 关键字开始一个功能或行为的具体描述块。该关键字之后的内容需要缩进

### 示例

```mcbc
func 计算总价:
input: 商品列表, 优惠码
output: 总金额, 应用的折扣
behavior:
    初始化一个变量来存储当前的总金额，初始值为零
    遍历商品列表中的每一个商品:
        对于每个商品，获取其价格，并累加到总金额变量中
        检查是否提供了优惠码
        如果提供了优惠码: 计算应用的折扣并更新总金额
    返回最终的总金额和应用的折扣变量的值
```

## 2. 对变量的明确描述

在行为描述过程中，我们允许使用隐含过程变量的描述来隐式地调用变量，也提供了明确的强制定义规则。

在 `.mcbc` 层，通过`var` 关键字强制让工具链识别：此处有一个开发者明确定义的变量

`var` 定义之后可以跟随一个可选的 `:` ，随后对变量进行一些精简的描述，例如如何初始化，或者应该使用什么类型的变量

如果开发人员强烈希望自始至终保证对变量的强掌控，可以使用 `$` 来进行明确的变量调用

但对于MCCP-toolchain来说，被明确指示过的变量（也包括input和output中的参数列表）都会自然地在随后的“语义分析-构建”过程中，被一个名为“建议器”的部件存储

“建议器”将会把被隐性调用的变量修改为对已定义变量的明确调用，理想情况下，开发人员无需分心关注此过程

*备注：考虑到未来自动补全插件的支持问题，同时也考虑到工具链的性能/效率问题，关于变量和已定义符号的明确使用语法还有改善空间，未来可能会出现一定程度的改变*

### 示例 (过程变量的描述)

```mcbc
func 计算总价:
input: 商品列表, 优惠码
output: 总金额, 应用的折扣
behavior:
    var 当前总金额: 初始化为0
    遍历商品列表中的每一个商品:
        对于每个商品，获取其价格，并累加到总金额中
        检查是否提供了优惠码
        如果提供了优惠码: 计算应用的折扣并更新 $当前总金额
    返回最终的 $当前总金额 和应用的折扣
```

## 3. 类的描述

在 `.mcbc` 层，我们使用 `class` 关键字声明一个类。

在类定义中，我们通过可选的`inh`关键字来描述类的继承。

对于类的构造/初始化函数以及析构函数并不提供强制规定，由于MCCP-toolchain本身是一个由llm驱动的工具链，它通常能够合理地解析目标语言风格的函数定义

类变量：直接在`class`代码块下声明，建议在代码块的顶端进行

实例变量/成员变量：声明时需要`self.`前缀，如：`self.myVar`

如果你希望进行类似python风格的动态变量管理，成员变量的声明和初始化可以在`__init__`方法中进行

如果你希望进行类似C++风格的明确变量管理，建议将`self.myVar` 等内容放在`class` 代码块的末尾，并在`__init__`中管理初始化过程

**特别注意：**
1. 始终谨记，mcbc **不是** 一门“编程语言”，它是一种“描述约定”。
2. 因此，我们在此仅对`class`这一概念进行最最基本/原始的框架定义，具体的设计哲学仍然应当遵循你所期望的目标语言的设计哲学
3. 无论对于哪一个目标语言，像类似于“多源继承”或“深层次继承”这种会造成混乱的实践始终都不被推荐。MCCP-toolchain 虽然不对此进行限制，但是会抛出可屏蔽的警告
4. 其它一些风格各异的目标语言特性（比如`interface`或者`virtual`之类）应该结合后文讲述的*意图注释*来进行定义。mcbc为了保持最大的灵活性和简洁性，不会提供过多关键字

### 示例

```mcbc
class ConfigManager:
inh : BaseClass
    var instance_count: 实例计数器
    
    func __init__:
    behavior:
        var self.configPath: 字符串
        初始化configPath
        var self.configParam: 字典
        instance_count++

    func 加载配置:
    behavior:
        尝试读取 this.configPath 指向的配置文件
        将配置文件内容加载进self.configParam
        若成功: 返回 true
        否则: 返回 false

    func 获取参数:
    input: configKey
    output: configParam
    behavior:
        var tempConfigParam: 初始化为none
        从已加载配置中查找configKey，存入tempConfigParam
        返回tempConfigParam

    // var self.configPath: 字符串
    // 类 C++ 风格的成员变量定义

```

## 4. 逻辑控制流

### 4.1 条件判断

`.mcbc` 描述分支控制时，允许通过明确的关键字控制，或者通过隐含分支的自然语言控制

目前提供的关键字有：`if` `else if` `else`

使用隐含分支关系的自然语言时请注意配合缩进与`:`的使用，工具链会尝试将其转化为明确的`if-else结构`

即便你没有提供`:`符号以及缩进，以现在大语言模型的能力也完全可以生成有效的代码，但我们仍建议保持良好的代码结构化习惯

语法:
`if <条件描述> :`
    `<结果或步骤描述>`
`else:`
    `<结果或步骤描述>`

#### 示例:

```mcbc
behavior:
    检查用户权限
    if 权限足够执行此操作: 
        执行操作并记录日志
    else:
        返回权限不足错误
    
```

```mcbc
behavior:
    尝试读取 this.configPath 指向的配置文件
    将配置文件内容加载进self.configParam
    若成功: 则返回 true
    否则: 返回 false
```

### 4.2 循环与迭代

`.mcbc` 描述循环/迭代逻辑时，允许通过特定的关键字控制，也允许通过隐含循环/迭代逻辑的自然语言控制

隐含地进行描述性表达“对集合中的每一个元素执行...”，或使用包括但不限于“遍历”、“对每个”、“循环处理”、“for each”等词语结合缩进和`:`符号表达迭代逻辑

与分支语句不同，mcbc不提供明确的循环/迭代关键字，这是因为现代编程语言中提供的风格特色各异的循环/迭代机制确实过于丰富，相对于分支逻辑而言，难以找到足够“兼收并蓄”的关键字描述

因此我们选择相信大模型的转化能力，让它自然判断你的编程逻辑需求

然而，和分支结构的建议一致，我们始终推荐你保持对`:`符号和结构化缩进的良好使用，这会让你的代码总是清晰易读，同时也有利于工具链后续的自动构建

语法:
`对列表中的每一个项:`
    `  <对当前项执行的操作>`

#### 示例

```mcbc
behavior:
    读取文件所有行到列表中
    对列表中的每一行:
        如果是注释行：跳过此行，不记录
        如果行不为空且不是注释行: 将内容append进入结果变量
    返回结果变量

```

### 4.3 错误处理与尝试

使用 `try...` 结构描述可能失败的操作，并结合 `if fails ...` 描述失败时的处理

对于不支持类似 try-catch 语法的目标语言而言，此类操作应当被转化为基本的分支语句

语法:
`try <操作描述>`

`if <操作描述> fails <失败处理描述>`

#### 示例

```mcbc
behavior:
    try 连接到数据库
    if 连接到数据库 fails  记录错误日志并终止操作
    else:
        执行数据库查询
        处理查询结果
```

## 5. 注释

`.mcbc` 文件支持两种类型的注释，用于不同的目的：

人员注释 (`//`): 常规的注释内容，主要面向代码阅读人员。mccp-toolchain 会直接忽略此注释

意图注释 (`@`): 用于提供额外的、非行为流程内的元信息，例如对代码行为的额外约束、性能要求、安全考虑、线程约束等。这些注释旨在对模型的理解和生成过程进行额外约束

- 当用户有一些不便于或不希望被包含在行为描述流程中的内容时，可以使用此意图注释。mccp-toolchain会对此类意图注释进行特定处理
- 意图注释的作用域是**其下方的代码块**，例如，在func前的意图注释会影响整个func的behavior，在分支块内的意图注释**应该和分支关键字本身平齐**，指示其作用域是下方整个分支代码块
- 例如，意图注释会出现在behavior块下方，或者if-else块下方，其缩进值和关键字保持平齐。
- 意图注释不应该被零散地使用，零散的意图注释实际上就是一种行为描述代码，大量混在行为描述代码中的 `@` 标识符只会造成混淆，请勿滥用
- 意图注释和被注释的代码块之间不允许出现空行

#### 示例

```mcbc
// 这个函数会进行系统的初始化，这段人员注释会被 mccp-toolchain 忽略
func 初始化系统:
input: 配置文件路径
output: 成功状态, 错误信息字符串
behavior:
@ 这个模块是高性能关键路径的一部分，模型生成代码时需要考虑效率。优先考虑运行时间短的算法，无需考虑空间占用。可以使用标准库的读取函数
    try 读取配置文件
    if 读取配置文件 fails 返回错误状态和信息
    else:
    @ 配置格式是 YAML，需要使用特定的解析库
        解析配置内容
        根据配置内容 初始化各个模块
        返回成功状态
```

## 6. 对外符号描述

在 `.mcbc` 文件中，我们引入 `description` 关键字，用于为特定的函数、变量、类等符号提供简洁的功能、职责或作用描述。该描述应尽量简明扼要，不超过50个汉字或30个英文单词

这一描述将作为符号的总结性说明，它并不在当前文件中进行作用，而是一种对外声明，用于后续大模型在处理依赖符号时，能进行合理的函数/类/全局变量调用

此关键字并非强制性要求，不过当你在使用MCCP-toolchain时，如果你的模型始终难以正确地考虑函数调用等依赖项，可以考虑利用description关键字进行额外的描述

语法:
`description: <描述文本>`

说明:
- `description` 关键字出现在 `func`、`var` 或 `class` 声明之后，不允许出现额外空行，对于`func`而言必须处在 `input`、`output` `behavior` 几个关键字之前
- 每个符号（函数、变量、类）最多只能有一个 `description` 描述
- 描述文本应简洁且清晰地表明一个符号的对外功能，特别关注符号调用的“结果/功能”而不是内部运行细节
- 局部变量暂时不应该出现 `description` 关键字描述，较远的未来中可能会规划带有作用域定义的description关键字

### 示例

对函数使用:
```mcbc
func 计算总价:
description: 根据商品列表和优惠码计算最终总价和折扣
input: 商品列表, 优惠码
output: 总金额, 应用的折扣
behavior:
    ...
```

对变量使用（必须用于对外可见的变量）:
```mcbc
class ConfigManager:
    var configPath: 字符串
    description: 存储配置文件的路径字符串

    func 加载配置
    behavior:
    ...
```

对类使用:
```mcbc
class ConfigManager:
description: 负责配置文件的加载和参数读取

    ...
```

## 7. 缩进约定 (indentation convention)

缩进在 `.mcbc` 文件中具有结构性意义，用于表示行为块的范围以及逻辑控制流的嵌套层级。建议使用一致的缩进单位（例如，4个空格）

input, output, behavior几个关键字是固定跟随在func后的。出于减少缩进数量的考虑，规定这几个固定位置的关键字直接和func关键字保持平齐

### 示例:

```mcbc
func 处理订单:
input: 订单数据
output: 处理结果
behavior:
    验证订单数据的完整性
    if 验证失败:
        记录验证失败日志
        打印失败信息
        返回失败原因代码
    else:
        检查库存
        if 库存充足:
            扣减库存
            生成支付请求
            返回支付请求信息
        else:
            标记订单为缺货
            通知用户
            返回缺货信息
```

## 完整示例

```
// config_manager.mcbc
// 配置管理模块，负责配置文件的加载和参数读取


class ConfigManager:
inh: BaseClass
description: 负责管理应用程序配置的加载和参数读取
@ 此模块为系统核心组件，需始终确保线程安全

    var configPath: 字符串
    description: 配置文件路径

    var configData: 字典
    description: 存储加载后的配置数据

    func 加载配置:
    description: 加载配置文件内容到内存
    input:
    output: 布尔值
    behavior:
        // 尝试读取配置文件
        try 打开并读取 this.configPath 指向的文件内容
        if 打开文件 fails:
            记录错误："无法打开配置文件"
            返回 false
        else:
        @ 配置文件格式为 JSON
            try 解析文件内容
            if 解析 fails:
                记录错误："配置文件格式错误"
                返回 false
            else:
                将解析后的JSON对象存入 this.configData
                返回 true

    func 获取参数:
    description: 根据参数名获取配置值
    input: 参数名: 字符串
    output: 字符串
    behavior:
        // 检查配置是否已加载
        if this.configData 为空:
            调用 this.加载配置()  // 尝试自动加载配置
            if 加载失败:
                返回 "配置未加载"

        // 查找参数值
        if 参数名 存在于 this.configData 中:
            返回 this.configData[参数名]
        else:
            记录警告："配置参数不存在：" + 参数名
            返回 ""

    func 设置参数:
    description: 更新配置参数值
    input: 参数名: 字符串, 参数值: 字符串
    output: 布尔值
    behavior:
        if this.configData 为空:
            调用 this.加载配置()
            if 加载失败:
                返回 false

        // 更新参数值
        this.configData[参数名] = 参数值
        返回 true

    func 保存配置:
    description: 将配置保存回文件
    input:
    output: 布尔值
    behavior:
        if this.configData 为空:
            返回 false

        try 打开 this.configPath 指向的文件进行写入
        if 打开文件 fails:
            记录错误："无法写入配置文件"
            返回 false
        else:
        @ 使用 JSON 格式保存
            将 this.configData 序列化为JSON字符串
            将JSON字符串写入文件
            关闭文件
            返回 true


func 初始化系统配置:
input:
output: 布尔值
behavior:
@ 这段代码是使用示例，在最终结果代码中必须全部注释，仅作为参考或者在功能测试时临时使用
    var 配置管理器 = new ConfigManager()
    配置管理器.configPath = "config/app_settings.json"

    if 配置管理器.加载配置() == false:
        记录错误："系统配置加载失败"
        返回 false
    else:
        var 服务端口 = 配置管理器.获取参数("server_port")
        if 服务端口 == "":
            配置管理器.设置参数("server_port", "8080")
            配置管理器.保存配置()

        返回 true

```
