# MCCP 符号表描述文件 (mccp_symbols.json) 规范

本规范详细定义了 MCCP 项目中的符号表文件 `mccp_symbols.json` 的结构、内容及其在整个开发流程中的作用，特别是其如何与 MCCP 的分层结构、文件命名约定和 `mccp_config.json` 配置协同工作。

## 1.文件目的与定位

`mccp_symbols.json` 的文件功能贯穿 MCCP 工程的所有构建流程。它集中记录了项目中跨越不同层级（行为描述层 `.mcbh`、符号-伪代码层 `.mcpc` 和目标代码层 `src_target`）的所有关键符号（Symbol）信息。

符号包括但不限于：

- 函数 (Functions)
- 方法 (Methods)
- 类 (Classes)
- 结构体 (Structs)
- 枚举 (Enums)
- 变量 (Variables, 包括全局变量、成员变量、局部变量)
- 常量 (Constants)
- 接口 (Interfaces)

该文件的主要作用是：

- 提供符号的单一真相来源 (Single Source of Truth)：确保不同层级对同一符号的引用具有一致的名称、类型和定义位置。
- 实现层级间的符号映射：明确一个符号在其对应的 `.mcbh` 文件、`.mcpc` 文件以及最终 `src_target` 文件中的定义位置，便于工具链进行层间导航和验证。
- 为 LLM 提供结构化上下文：在代码生成过程中，LLM 可以查阅符号表，获取关于符号的详细元数据（如类型、参数、返回类型、描述等），从而生成更精确、符合预期的代码。
- 辅助工具链功能：支持如符号查找、交叉引用、自动完成、重构等开发工具特性。
- 辅助反向构建: 在反向构建现有代码时，符号表是优先被构建的关键组件，它承载了对现有代码结构和符号的初步识别结果。

`mccp_symbols.json` 与 `mccp_config.json` 协同工作：`mccp_config.json` 定义了项目的宏观配置，包括目标语言和文件命名规则 (`is_extra_suffix` 等)，而 `mccp_symbols.json` 则提供了项目内部具体代码元素的详细信息，这些信息会受 `mccp_config.json` 中语言和命名规则的影响（例如，源文件路径的记录方式）。

## 2.文件位置与类型

MCCP 项目采用分布式符号表结构。`mccp_symbols.json` 文件并非集中存放在单一目录下，而是根据项目的模块化结构，分散存放于 `src_mcbh/` 和 `src_mcpc/` 目录下的各级子文件夹中。

/ 项目根目录
├── config/
│   └── mccp_config.json
├── src_mcbh/
│   ├── module_a/
│   │   └── mccp_symbols.json  <-- 管理 module_a 内的符号
│   └── module_b/
│       ├── submodule_c/
│       │   └── mccp_symbols.json  <-- 管理 submodule_c 内的符号
│       └── mccp_symbols.json  <-- 管理 module_b 根目录内的符号
├── src_mcpc/
│   ├── module_a/
│   │   └── mccp_symbols.json  <-- 管理 module_a 内的符号
│   └── ...
└── src_target/
└── ...

每个 `mccp_symbols.json` 文件独立管理其所在目录层级下的 `.mcbh` 和 `.mcpc` 文件的对应符号表信息。这种分布式结构使得符号表与代码文件紧密耦合，更易于管理和理解局部模块的符号。

在此分布式结构基础上，MCCP 引入了三种特定用途的符号表文件概念：

- 单一符号表 (Single Symbol Table): 直接以单一文件的形式放置于src_mcbh或src_mcpc的某一模块目录下，文件命名`mccp_symbols_single.json`，直接描述该模块内所有源代码文件的符号信息。适用于相对简单的工程，也即模块文件夹内不包含过多的源码文件的情况。
- 多文件符号表 (Multi-Symbol Table): 和子符号表共同放置在src_mcbh或src_mcpc的某一模块目录下，"sub_symbols_files"键值将会存储该模块内所有子文件的符号表文件路径。适用于模块文件夹内包含大量不同源代码文件的复杂工程。
- 子符号表 (Child Symbol Table): 归属于某一多文件符号表，其内容基本等同于单一符号表，只是为了对复杂工程的符号表进行更细粒度的拆分管理，便于维护和理解，也同时便于多人协作开发的场景，不同人可以分别维护自己负责的子模块的子符号表。
- 脚本型符号表 (Scripted Symbol Table): 是一种特殊类型的符号表文件，其主要内容并非手动维护的符号列表，而是定义了通过自动化脚本或模板批量生成符号的规则和配置。这类符号表文件的文件名以 `_scripted.json` 结尾。此符号表可以是多文件符号表的子文件(`mccp_symbols_scripted_sub1.json`)，也可以自己作为单一符号表存在（范例中的 `mccp_symbols_scripted.json`）。

## 3.分布式符号表结构

分布式符号表文件（非脚本型）的顶层结构为一个 JSON 对象，包含以下字段：

- `dir_content`:
    - 类型: object
    - 描述: 存储其自身所在目录下的源代码文件的文件名。key 为当前目录下的文件的名称，不包括扩展名。节点内还有此文件中对应的具体符号表，符号表具有嵌套结构。可以包括但不限于：类 函数 变量 常量 接口等。

- `symbols_param`:
    - 类型: object
    - 描述: 存储需要额外描述的符号的参数属性。包括符号类型（类 函数 变量 等等）、符号功能的附加说明描述（提供给大模型作为提示词上下文的一部分）、是否冻结、符号作用域，等等。

- `ignore_list`:
    - 类型: array of strings
    - 描述: 存储在当前目录层级下，被忽略的文件的完整路径（相对于项目根目录）或文件名（相对于当前符号表文件）。这些文件不会参与符号表的更新，也不会被解析或使用。

- `frozen_list`:
    - 类型: array of strings
    - 描述: 存储在当前目录层级下，被冻结的文件的完整路径（相对于项目根目录）或文件名（相对于当前符号表文件）。这些文件内的符号仍然可以被调用和参考，但文件本身不会被纳入 MCCP 工程的修改范围。

## 4.符号对象核心字段说明

在 `dir_content` 下，存储了当前符号表所在目录下的源代码文件的文件名。每个文件的名称作为 key，对应一个符号对象，符号对象包含以下字段：

（等待填充）

## 5.单一符号表、子符号表、脚本型符号表概念

在分布式符号表的文件组织方式下，不同位置和内容的 `mccp_symbols.json` 文件扮演着不同的角色：

- 单一符号表 (Single Symbol Table): 用于小规模的相对简单工程的构建，直接描述该模块内所有源代码文件的符号信息。
- 多文件符号表 (Multi-Symbol Table): 用于包含大量不同源代码文件的复杂工程的构建，主要目的是为了对复杂工程的符号表进行更细粒度的拆分管理，便于维护和理解。
- 子符号表 (Sub Symbol Table): 被多文件符号表的"sub_symbols_files"键值所引用，其内容基本等同于单一符号表，只是为了对复杂工程的符号表进行更细粒度的拆分管理，便于维护和理解；也同时便于多人协作开发的场景，不同人可以分别维护自己负责的子模块的子符号表。
- 脚本型符号表 (Scripted Symbol Table): 是一种特殊类型的符号表文件，其主要内容并非手动维护的符号列表，而是定义了通过自动化脚本或模板批量生成符号的规则和配置。这类符号表文件的文件名以 `_scripted.json` 结尾。此符号表可以自行作为单一符号表存在，也可以归属于某一多文件符号表的子符号表。（未实现）

这几种符号表类型协同工作，共同构成了 MCCP 项目完整的、分布式、可维护且部分可自动生成的符号信息系统。

## 6.脚本型符号表详细定义与示例

- **等待后续实际实现，当前低优先级，暂不在开发计划内**

脚本型符号表 (`type: "scripted"`) 文件定义了如何通过自动化方式生成符号条目，主要用于处理大量重复或模式化的符号定义。其核心在于提供生成规则和配置，而不是完整的静态符号列表。

以下是一个脚本型符号表的 JSON 示例（未实现）

脚本型符号表的特有功能字段解释如下（未实现，临时填充，不作为最终开发决定，请谨慎阅读）：

- `scripting_solution`:
    - 类型: string
    - 描述: 可用于生成符号的脚本化方案。例如"LLM"（指借助LLM的功能进行生成）, "Python"（指借助自定义python脚本进行生成）, "built-in"（指使用MCCP内置的简单替换脚本进行生成），等。

- `base_symbol_pattern`:
    - 类型: array of objects
    - 描述: 定义了一系列基底符号模式或前缀。这些模式本身不是完整的符号，而是用于批量生成符号时的命名基础。

- `fill_template`:
    - 类型: array of objects
    - 描述: 定义了不同符号类型（如函数、类、变量）的填充模板。这些模板是符号结构的骨架。

- `generation_hints_prompt`:
    - 类型: object
    - 描述: 专用于"LLM"的生成方案，包含用于指导 LLM 在生成代码时参考这些脚本化生成的符号的备注提示词。例如，`mccp_code_generation_prompt` 字段提供了给 LLM 的具体指令，强调遵循符号定义、参数、返回值和语义约定，并提及如何处理模板符号。

脚本型符号表的引入，使得 MCCP 能够通过预定义的规则和自动化流程，高效、一致地管理和生成大规模的符号定义，这对于大型项目或需要频繁创建模式化代码的场景尤为重要（未实现）。

## 7.与层级文件路径的关联

在分布式符号表结构下，符号与其所在的 `.mcbh` / `.mcpc` 文件位置紧密关联。每个目录下的 `mccp_symbols.json` 文件都隐式地管理其所在目录下的所有文件符号。

工具链在处理符号表时，会根据 `mccp_config.json` 的文件系统映射规则来计算出正确的 `.mcbh` 和 `.mcpc` 文件路径，并将对应内容记录到符号表中，主要是在 `dir_content` 的文件条目中记录文件名和对应的层次化符号表。

关键点在于：

- `.mcbh` 和 `.mcpc` 文件路径中是否包含额外后缀 (`_h`, `_c`, `_cpp`, `_py`, `_java` 等) 完全取决于 `mccp_config.json` 中指定的 `targetLanguage` 和 `fileSystemMapping.is_extra_suffix` 的规则，以及原始目标文件 (`src_target`) 的扩展名。
- 分布式符号表文件 (`mccp_symbols.json`) 本身不决定命名约定，它只是在各自的目录层级记录由约定产生的实际文件名和结构。单一符号表和子符号表通过嵌套或引用来反映目录层级关系。
- 脚本型符号表则定义了生成符合这些命名约定和文件结构的符号的规则。

## 8.符号表在 MCCP 工作流程中的作用

符号表是 MCCP 各个抽象层级协同工作的核心构件，尤其在行为描述层和符号-伪代码层的构建与迭代中起着至关重要的作用：

- 行为描述层构建阶段:
    - 在大模型将自然语言需求拆解为行为描述并构建初步软件框架（文件、类、函数等）时，会初步创建分布式符号表文件。
    - 此时，各个目录下的符号表文件会记录行为描述中显式提到的或根据描述推断出的主要符号（如类名、函数名、重要变量名）及其所属文件和大致作用域。这一阶段的符号表可能不包含详细的局部变量，但框架结构和关键文件/目录级符号已被捕捉。单一符号表可能在此时被创建，用于定义顶层结构或全局符号。

- 符号-伪代码层构建阶段:
    - 大模型根据行为描述层的内容生成符号-伪代码层时，会进一步填充和更新相应的分布式符号表文件。
    - 这个阶段会细化符号表，记录伪代码中出现的更具体的符号，例如函数参数、局部变量、类成员变量、以及伪代码中体现出的函数/方法调用和类实例化等关系。
    - 伪代码中的导入/依赖声明（如 `import X from "file"`）会用于填充或更新符号表中的文件依赖关系信息（可能作为 `addition_symbol_param` 或在文件结构中体现）。

- 迭代与更新过程:
    - 无论是开发人员在行为描述层进行的修改，还是大模型在生成伪代码后进行的自我修正，任何引入新符号、删除符号、修改符号名称/作用域、或改变依赖关系的操作，都应触发相关分布式符号表文件的迭代更新。
    - 大模型负责分析这些修改，并同步反映到受影响的局部符号表文件中。例如，如果某个模块的行为描述增加了功能，该模块目录下的 `mccp_symbols.json` 就应被更新。如果修改了某个函数的实现方式，引入了新的局部变量，该函数所在文件对应的符号表条目下的 `inner_symbols` 就应被更新。
    - 在每次重要的生成或修改后，受影响的符号表文件都应被重新验证，确保其与当前的行为描述和符号-伪代码层内容一致。

- 符号-伪代码层的使用与验证:
    - 在生成符号-伪代码时，大模型会参考当前目录及关联层级（通过单一符号表、子符号表关联）的符号表，使用其中记录的规范符号名称，并根据依赖关系组织伪代码结构。
    - 生成伪代码后，可以根据符号表对伪代码中的符号引用进行静态检查，验证所有调用的函数、访问的变量是否都在符号表中存在且在当前作用域可访问，从而捕获潜在的“幻觉”引用。

- 文件依赖管理:
    - 分布式符号表通过其文件结构和内容（可能在 `addition_symbol_param` 或专门字段中）记录文件间的依赖关系。
    - 这对于大模型在最终代码生成阶段组织文件、确定编译/解释顺序（如果适用）以及生成正确的导入语句至关重要。它确保了代码生成过程能够遵循项目定义的模块化结构和依赖关系。

- 脚本型符号表的应用:
    - 脚本型符号表在项目初始化或需要批量生成模式化符号时发挥作用。工具链会读取脚本型符号表文件，执行其中定义的生成规则，然后将生成的具体符号定义填充到相应的常规分布式符号表文件中。这使得符号表的初始化和填充更加高效和规范。

简而言之，符号表是 MCCP 实现“精确化、可信化、可控化”的关键技术载体，它为大模型的代码生成和项目结构的理解提供了必要且精确的元数据支持，并且通过分布式和脚本化的设计，提高了大型项目的可维护性和自动化水平。

## 9.示例

以下将提供一个 `mccp_symbols_single.json`的示例，它记录了其所在目录下的所有文件，以及各个文件内对应的嵌套式/层级化符号表。完整内容和请前往"mccp_symbols_template"目录下查看。

```json
{
    "dir_content": {
        "file1": {
            "function1":"bottom",
            "ClassA":{
                "method1":"bottom",
                "method2":{
                    "local_var1":"bottom",
                    "local_var2":"bottom"
                },
                "class_variable1":"bottom"
            },
            "global_var1":"bottom",
            "file_level_variable":"bottom"
        },
        "file2": {
            "global_var3":"bottom"
        }
    },
    "symbols_param": {...},
    "ignore_list": [
        "path/to/ignored_file1",
        "path/to/ignored_dir"
    ],
    "frozen_list": [
        "path/to/frozen_file1",
        "path/to/frozen_dir"
    ]
}

```

*其它备注：在分布式结构中，`ignore_list` 和 `frozen_list` 中的路径是，相对于**当前**符号表文件所在目录内的文件/文件夹，可以（但不建议）写为绝对路径。**禁止**写入次级文件夹内的文件内容*

## 10.更新与维护

`mccp_symbols.json` 文件需要与项目的 `.mcbh`, `.mcpc` 文件以及最终的 `src_target` 代码保持同步。随着项目的开发，新的符号会被添加，现有符号可能会被修改或删除。维护符号表的准确性至关重要。

符号表的更新与维护应遵循以下开发哲学/工程建议：

- 主要由自动化流程生成和更新:
    - 基于行为描述层 (`.mcbh`) 和符号-伪代码层 (`.mcpc`) 的内容，工具链（通常调用大模型）会负责自动创建、填充和更新相应的分布式符号表文件。
    - 从 `src_target` 到 `.mcpc` 和 `mccp_symbols.json` 的反向构建也应由自动化工具完成，依赖特定实现的解析器 (**高优先级**，等待开发)。

- 开发人员的职责:
    - 我们理解并支持开发者对于符号表的高度掌控和亲手修改的需求，所以并不会禁止直接编辑符号表，也会提供相应的同步机制。
    - 但是开发人员不应**过于频繁**地直接手动编辑 `mccp_symbols.json` 文件，这有很大可能会加重开发负担，并反而导致犯下**粗心的错误**。
    - 当需要修改符号表时，相对合理的方式应该是回到行为描述层进行修改，触发自动化流程以更新符号表。
    - 开发人员对生成的符号表应该随时保持清晰的认知并时刻进行审查，检查符号命名、作用域、提示词描述，确保未来生成代码的正确性。
    - 推荐使用工具提供的可视化界面或差异对比功能进行审查（未实现，等待开发）。

- 对于手动编辑的建议:
    - 如果确实需要手动调整符号元数据，应确保你对"is_frozen"字段的合理使用，避免手动修改的内容被自动生成所覆盖。
    - 符号表对mccp生成可信代码的过程极端重要，确保你对mccp的工作流程和符号表的更新流程有清晰的理解和把握。
    - 保证对于git/svn等版本管理工具的良好理解，以避免难以处理的合并冲突。
    - 和你的团队成员保持良好沟通，与他们保持消息同步。**不要在协作中轻易擅自修改他人负责的、或与接口相关的符号表，这可能会是一种非常恶劣的行为**
