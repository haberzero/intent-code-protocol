# MCCP 符号表描述文件 (mccp_symbols.json) 规范

本规范详细定义了 MCCP 项目中的符号表文件 `mccp_symbols.json` 的结构、内容及其在整个开发流程中的作用，特别是其如何与 MCCP 的分层结构、文件命名约定和 `mccp_config.json` 配置协同工作。

## 1.文件目的与定位

`mccp_symbols.json` 的文件功能贯穿 MCCP 工程的所有构建流程。它集中记录了项目中跨越不同层级（行为描述层 `.mcbc`、符号-伪代码层 `.mcpc` 和目标代码层 `src_target`）的所有关键符号（Symbol）信息。

符号包括但不限于：

- 函数 (Functions)
- 类 (Classes)
- 方法 (Methods)
- 结构体 (Structs)
- 枚举 (Enums)
- 变量 (Variables, 包括全局变量、成员变量、局部变量)
- 常量 (Constants)
- 接口 (Interfaces)

该文件的主要职责：

- 提供符号的单一真相来源 (Single Source of Truth)：确保代码生成过程中的符号引用具有正确一致的名称和来源
- 实现层级间的符号映射：明确一个符号在其对应的 `.mcbc` 文件、`.mcpc` 文件以及最终 `src_target` 文件中的定义位置，便于工具链进行层间导航和验证
- 为 LLM 提供结构化上下文：在代码生成过程中，LLM 可以查阅符号表，获取关于符号的详细元数据（如类型、参数、返回类型、描述等）作为上下文，从而生成更精确且符合预期的代码
- 反向构建协同: 在反向构建现有代码时，符号表是优先被构建的关键组件，它承载了对现有代码结构和符号的初步识别结果
- 提供额外辅助功能：支持如符号查找、交叉引用、自动补全、重构 等工具特性，为未来的vscode插件化开发提供一定基础

## 2.文件位置与类型

MCCP 项目采用分布式的符号表结构。`mccp_symbols.json` 文件并非集中存放在单一目录下，而是根据项目的模块化结构，分散存放于 `src_mcbc/` 和 `src_mcpc/` 目录下的各级子文件夹中

```text
/ 项目根目录
├── config/
│   └── mccp_config.json
├── src_mcbc/
│   ├── module_a/
│   │   └── mccp_symbols.json  <-- 管理 module_a 目录内的符号
│   └── module_b/
│       ├── submodule_c/
│       │   └── mccp_symbols.json  <-- 管理 submodule_c 目录内的符号
│       └── mccp_symbols.json  <-- 管理 module_b 目录内的符号
├── src_mcpc/
│   ├── module_a/
│   │   └── mccp_symbols.json  <-- 管理 module_a 目录内的符号
│   └── ...
└── src_target/
└── ...
```

每个 `mccp_symbols.json` 文件独立管理其所在目录层级下的 `.mcbc` 和 `.mcpc` 文件的对应符号表信息

## 3.符号表的内容

非脚本型符号表文件的顶层结构为一个 JSON 对象，包含以下字段：
- `depend_content`:
    - 类型: object
    - 描述: 存储当前符号表文件所依赖的其他符号表文件的路径。

- `dir_content`:
    - 类型: object
    - 描述: 存储其自身所在目录下的源代码文件的文件名。key 为当前目录下的文件的名称，不包括扩展名。节点内还有此文件中对应的具体符号表，符号表具有嵌套结构。可以包括但不限于：类 函数 变量 常量 接口等。

- `symbols_param`:
    - 类型: object
    - 描述: 存储需要额外描述的符号的参数属性。包括符号类型（类 函数 变量 等等）、符号功能的附加说明描述（提供给大模型作为提示词上下文的一部分）、是否冻结、符号作用域，等等。

- `ignore_list`:
    - 类型: array of strings
    - 描述: 存储在当前目录层级下，被忽略的文件的完整路径（相对于项目根目录）或文件名（相对于当前符号表文件）。这些文件会被mccp-toolchain忽略

- `frozen_list`:
    - 类型: array of strings
    - 描述: 存储在当前目录层级下，被冻结的文件的完整路径（相对于项目根目录）或文件名（相对于当前符号表文件）。mccp-toolchain会尝试获取它们的符号表，但不会修改其中的源码内容

## 4.符号对象核心字段说明

在 `dir_content` 下，存储了当前符号表所在目录下的源代码文件的文件名。每个文件的名称作为 key，对应一个符号对象，符号对象包含以下字段：

（等待完善）

## 5.单一符号表、子符号表、脚本型符号表概念

MCCP 引入了三种特定用途的符号表文件概念（目前仅规划实现单一符号表，脚本型符号表的实现优先级极低）

- 单一符号表 (Single-file Symbol Table): 用于小规模的相对简单工程的构建，直接描述该模块内所有源代码文件的符号信息
- 多文件符号表 (Multi-file Symbol Table): 用于包含大量不同源代码文件的复杂工程的构建，主要目的是为了对复杂工程的符号表进行更细粒度的拆分管理，便于维护和理解，也便于多人协作开发和职责分配
- 子符号表 (Sub Symbol Table): 归属于多文件符号表，其内容基本等同于单一符号表，目的是对复杂工程的符号表进行更细粒度的拆分管理，便于维护和理解，也便于多人协作开发和职责分配
- 脚本型符号表 (Scripted Symbol Table): 是一种特殊类型的符号表文件，定义了通过自动化脚本或模板批量生成符号的规则和配置。这类符号表文件的文件名以 `_scripted.json` 结尾。此符号表可以自行作为单一符号表存在，也可以归属于某一多文件符号表的子符号表

这几种符号表类型协同工作，共同构成了 MCCP 项目完整的、分布式、可维护且部分可自动生成的符号信息系统

## 6.脚本型符号表详细定义与示例

**等待更远的未来规划，当前低优先级，暂不在开发计划内。后续内容为占位符，不作为实际开发计划和决定，谨慎阅读**

脚本型符号表 (`type: "scripted"`) 文件定义了如何通过自动化方式生成符号条目，主要用于处理大量重复或模式化的符号定义。其核心在于提供生成规则和配置，而不是完整的静态符号列表

以下是一个脚本型符号表的 JSON 示例（未实现）

脚本型符号表的特有功能字段解释如下（未实现，临时占位符，不作为最终开发决定，请谨慎阅读）：

- `scripting_solution`:
    - 类型: string
    - 描述: 可用于生成符号的脚本化方案。例如"LLM"（指借助LLM的功能进行生成）, "Python"（指借助自定义python脚本进行生成）, "built-in"（指使用MCCP内置的简单替换脚本进行生成），等

- `base_symbol_pattern`:
    - 类型: array of objects
    - 描述: 定义了一系列基底符号模式或前缀。这些模式本身不是完整的符号，而是用于批量生成符号时的命名基础

- `fill_template`:
    - 类型: array of objects
    - 描述: 定义了不同符号类型（如函数、类、变量）的填充模板。这些模板是符号结构的骨架

- `generation_hints_prompt`:
    - 类型: object
    - 描述: 专用于"LLM"的生成方案，包含用于指导 LLM 在生成代码时参考这些脚本化生成的符号的备注提示词。例如，`mccp_code_generation_prompt` 字段提供了给 LLM 的具体指令，强调遵循符号定义、参数、返回值和语义约定，并提及如何处理模板符号

脚本型符号表将使得 MCCP 能够通过预定义的规则和自动化流程高效、一致地管理和生成大规模的重复性符号定义，这对于大型项目或需要频繁创建模式化代码的场景尤为重要

## 7.符号表在 MCCP 工作流程中的作用

- 行为描述层构建阶段:
    - 在大模型将自然语言需求拆解为行为描述并构建初步软件框架（文件、类、函数等）时，会初步创建分布式符号表文件
    - 此时，各个目录下的符号表文件会记录行为描述中显式定义符号，或根据描述推断出隐式定义的符号（如类名、函数名、重要变量名）。这一阶段的符号表可能不包含详细的局部变量，但框架结构和关键文件/目录级符号已被捕捉

- 符号-伪代码层构建阶段:
    - 大模型根据行为描述层的内容生成符号-伪代码层时，会直接读取符号表文件的内容作为上下文，并在构建过程中进一步填充和更新相应的分布式符号表文件，保存至mcpc目录下
    - 符号表将被细化，mccp-toolchain将记录伪代码中出现的更具体的符号，例如函数参数、局部变量、类成员变量、以及伪代码中体现出的函数/方法调用和类实例化等关系
    - 伪代码中的导入/依赖声明（如 `import X from "file"`）会用于填充或更新符号表中的文件依赖关系信息（可能作为 `addition_symbol_param` 或在文件结构中体现）

- 符号-伪代码层的使用与验证:
    - 在生成符号-伪代码时，大模型会参考当前目录及关联层级的符号表，使用其中记录的规范符号名称，并根据依赖关系组织伪代码结构
    - 生成伪代码后，可以根据符号表对伪代码中的符号引用进行静态检查，验证所有调用的函数、访问的变量是否都在符号表中存在且在当前作用域可访问，从而捕获潜在的“幻觉”引用

- 迭代与更新过程:
    - 无论是开发人员在行为描述层进行的修改，还是大模型在生成伪代码后进行的自我修正，任何引入新符号、删除符号、修改符号名称/作用域、或改变依赖关系的操作，都应触发相关分布式符号表文件的迭代更新
    - 大模型负责分析这些修改，并同步反映到受影响的局部符号表文件中。例如，如果某个模块的行为描述增加了功能，该模块目录下的 `mccp_symbols.json` 就应被更新
    - 在每次重要的生成或修改后，受影响的符号表文件都应被重新验证，确保其与当前的行为描述和符号-伪代码层内容一致

- 文件依赖管理:
    - 分布式符号表通过其文件结构和内容（可能在 `addition_symbol_param` 或专门字段中）记录文件间的依赖关系
    - 这对于大模型在最终代码生成阶段组织文件、确定编译/解释顺序（如果适用）以及生成正确的导入语句至关重要。它确保了代码生成过程能够遵循项目定义的模块化结构和依赖关系

- 脚本型符号表的应用:
    - 脚本型符号表在项目初始化或需要批量生成模式化符号时发挥作用。工具链会读取脚本型符号表文件，执行其中定义的生成规则，然后将生成的具体符号定义填充到相应的常规分布式符号表文件中。这使得符号表的初始化和填充更加高效和规范

简而言之，符号表是 MCCP 实现“精确化、可信化、可控化”的关键技术载体，为mccp-toolchain提供了必要且精确的元数据支持

## 9.示例

以下将提供一个 `mccp_symbols_single.json`的示例，它记录了其所在目录下的所有文件，以及各个文件内对应的嵌套式/层级化符号表。完整内容和请前往"mccp_symbols_template"目录下查看

```json
{
    "depend_content": {
        "file1": ["file2"],
        "file2": []
    },
    "dir_content": {
        "file1": {
            "function1":"bottom",
            "ClassA":{
                "method1":"bottom",
                "method2":{
                    "local_var1":"bottom",
                    "local_var2":"bottom"
                },
                "class_variable1":"bottom"
            },
            "global_var1":"bottom",
            "file_level_variable":"bottom"
        },
        "file2": {
            "global_var3":"bottom"
        }
    },
    "symbols_param": {...},
    "ignore_list": [
        "path/to/ignored_file1",
        "path/to/ignored_dir"
    ],
    "frozen_list": [
        "path/to/frozen_file1",
        "path/to/frozen_dir"
    ]
}

```

备注：`ignore_list` 和 `frozen_list` 中存储的路径是相对于**当前**符号表文件所在目录内的文件/文件夹的相对路径，可以（但不建议）写为绝对路径。**禁止**写入次级文件夹或父文件夹内的文件内容

## 10.更新与维护

`mccp_symbols.json` 文件需要与项目的 `.mcbc`, `.mcpc` 文件以及最终的 `src_target` 代码保持同步。随着项目的开发，新的符号会被添加，现有符号可能会被修改或删除。维护符号表的准确性至关重要

符号表的更新与维护应遵循以下开发哲学/工程建议：

- 主要由自动化流程生成和更新:
    - 基于行为描述层 (`.mcbc`) 和符号-伪代码层 (`.mcpc`) 的内容，mccp-toolchain会负责自动创建、填充和更新相应的符号表文件
    - 从 `src_target` 到 `.mcpc` 和 `mccp_symbols.json` 的反向构建也由mccp-toolchain完成（规划中）

- 开发人员的职责:
    - 我们理解并支持开发者对于符号表的高度掌控和亲手修改的需求，所以并不会禁止直接编辑符号表，也会在未来提供相应的同步机制
    - 但是开发人员不应**过于频繁**地直接手动编辑 `mccp_symbols.json` 文件，这有很大可能会加重开发负担，并反而导致犯下**粗心的错误**
    - 当需要修改符号表时，相对合理的方式应该是回到行为描述层进行修改，触发自动化流程以更新符号表
    - 开发人员对生成的符号表应该随时保持清晰的认知并时刻进行审查，检查符号命名、作用域、提示词描述，确保未来生成代码的正确性

- 对于手动编辑的建议:
    - 如果确实需要手动调整符号元数据，应确保你对"is_frozen"字段的合理使用，避免手动修改的内容被自动生成所覆盖。
    - 符号表对mccp生成可信代码的过程极端重要，确保你对mccp的工作流程和符号表的更新流程有清晰的理解和把握。
    - 保证对于git/svn等版本管理工具的良好理解，以避免难以处理的合并冲突。
    - 和你的团队成员保持良好沟通，与他们保持消息同步。
