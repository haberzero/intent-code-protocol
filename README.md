# MCCP:  model-context-code-protocol
本仓库描述了一个名为MCCP - Model Context Code Protocol的中间层协议，此协议旨在明确大语言模型的编程行为规范，使vibe-coding成为一种真正具备工程价值的编码模式
current version: v0.0.1

# MCCP 初期文档

## 基本需求描述

构想中的一种半自然语言编程描述系统，目前，我将其命名为MCCP: Model Context Code Protocol。这事实上不是一门新的编程语言，且永远都不应该成为一种可以直接“运行”或者“编译”的编程语言，它应当是一种让大语言模型能够和实际编程语言进行“精确化、可信化、可控化沟通”的约定，是一种伪代码形式的提示词协议，是一种沟通传统编程语言和大模型的超级中间件。更通俗地来讲，它应该能让大模型生成的代码变得稳定可控，且允许开发人员进行精细化修改、在多个抽象层次修改，并关联影响到其它层级的内容。

## 对MCCP的基本描述

MCCP的基本结构 - 三个抽象层级：符号-伪代码层，半自然语言行为描述层，自然语言提示词层。

*   自然语言提示词层：就是人类之间相互沟通、人类和语言模型进行直接沟通的最基本自然的口语化语法，对于MCCP而言，本层指代了对“软件需求/编程需求”的直接口语化描述。

*   半自然语言行为描述层：是对自然语言提示词层的具象化需求拆解。在这个拆解过程中，最初的软件框架将会形成，包括 - 项目文件夹的结构，软件的基本构成框架，软件的运行流程描述，软件中的类、函数、变量，业务分支逻辑，等等 - 在内的，对软件结构的实际行为描述，在这一层被构建。与此同时，在构建此层级时，代码的关键符号表将会被生成，包括但不限于关键的全局变量、全局单例等符号会被精确描述，从而能够在后续生成可信的伪代码间的关联结构，防止模型幻觉带来的调用不存在的函数/变量/实例等问题。本层级就像是一种对于软件源代码的完备注释。在与大模型的首次几轮的需求对话结束后，开发人员应该花费超过总工程一半的时间在本层级进行进一步开发。
    注：为了方便起见，本层级在后续内容将被称为行为描述层。

*   符号-伪代码层：已经非常接近实际的可编译/可运行代码。本层是具备标准客观的语法结构的层级，具备现代编程语言中最常见的所有元概念和结构，包括但不限于：分支/循环语法，顺序执行结构，变量定义，函数定义，类定义，配置定义，宏定义，等等。对于任何一个具备良好编程素养的开发人员来说，他们应该能够根据此层级的伪代码结构编写出具备完全相同逻辑功能的代码，仅仅在少量细节语法结构等内容上存在区别。此外，本层级应该已经具备近乎完整的符号表记录和符号使用，包括但不限于变量命名、函数命名、类命名等，伪代码中的互相依赖关系应该能够完全和符号表进行一一对应，从而确保后续大模型根据伪代码生成实际代码时，几乎一定能够构建出具备正确依赖关系和正确语法的可编译/可执行代码，最大限度地避免幻觉问题，同时最大限度地减少不同语言模型之间的代码内容差异，使符号-伪代码层具备良好的可迁移性。开发人员不应该在本层投入过多的精力进行精细化微调，也不应该过分纠结于本层级的具体语法，本层级的构建结果未来会随大模型进化而演进。开发人员的角色应转向类似“产品经理”，精细调整的是需求、行为描述。

从上述关于抽象分层的描述中可知，MCCP事实上几乎就是对传统软件开发的工程构建哲学的具象化拆解重构。它“几乎就是”一门新的编程语言，一门针对现代大模型构建的编程语言，然而它永远不应该被直接运行或者编译。这个协议自诞生之初就注定了它的快速演进性质，它永远都会跟随大模型本身的进化而快速地演进，任何被彻底定义的语法结构都会导致其丧失快速迭代进化的能力。

## MCCP具备的基本功能/特征

1.  跨层级修改反应：在不同层级之间的修改，甚至是对最终生成的实际编程代码的修改，其修改都应该被直接反应在直接相关联的抽象层上。举例而言，当一个开发人员修改了行为描述层的内容，此时，大模型应该开始一轮判断：
    *   软件的核心功能是否被修改？用户最初的自然语言提示/需求是否应该出现一个特别的备注，注明某函数应该用被修改后的特定方式实现。而后，根据判断内容向用户提交修改结果，交由开发者判断修改是否成立。
    *   符号-伪代码层应该被对应修改，使得伪代码能够准确对应开发人员在行为描述层进行的新修改。而后，修改结果应交由开发者判断是否成立。
    *   假如修改中涉及到了对符号表的修改，则符号-伪代码层的符号表以及依赖关系等也应当被对应修改。
    上述所有操作，在理论中都应该被大语言模型自动执行。

2.  兼容性描述文件：MCCP包含一个兼容性描述文件，此文件对应于传统软件工程中的“配置文件”概念，初步定义中是一个json文件。本文件描述内容包括但不限于：
    *   当前MCCP工程调用的具体大模型（Qwen/ChatGPT/DeepSeek 等），确保协作人员不因模型差异造成合并冲突。
    *   当前MCCP工程最终所能生成的具体编程语言(Python/C++/JAVA 等)，考虑兼容性和可构建性，MCCP应当限定最终的目标语言。
    *   当前MCCP需要调用的功能库/源代码库，定义工程依赖的库/现有代码并进行版本对齐。

3.  符号表：符号表是一个贯穿整个MCCP工程的json文件，其结构大致如下：
    ```
    {
        "global": {
            "var": [
                "some global var"
            ],
            "class": [
                "some class name"
            ],
            "func": [
                "some func name"
            ]
        },
        "file1": {
            "path":"path to file 1",
            "file_depend":"file2",
            "class_a": {
                "func": [],
                "var": []
            },
            "class_b": {
                "func": [],
                "var": []
            },
            "func_a": {
                "var": []
            },
            "var": []
        },
        "file2": {
            "path":"path to file 2",
            "class_c": {
                "func": [],
                "var": []
            },
            "func_b": {
                "var": []
            },
            "var": []
        }
    }
    ```
    符号表在行为描述层和符号-伪代码层被构建过程中应该被反复迭代。生成行为描述层后生成初步符号表，生成符号-伪代码层后更新符号表。后续开发人员迭代时，符号表逐渐趋于完整，存储所有可能涉及的符号内容。符号表中还存储文件依赖关系。符号表不应被开发人员过多手动修改，应借助大模型更新，审查是重点。

4.  结构化注释：MCCP与提示词工程高度相关，希望借用已有经验。结构化注释主要出现在行为描述层。注释分两种类型：人员注释和模型注释。
    *   人员注释 (`//`)：提供给开发者阅览，在符号-伪代码层生成过程中只被原封不动传递，永远不会被大模型看见。
    *   模型注释 (`@`)：提供给大模型进行额外的行为调整，用于特化调整模型行为。
    所有注释都可以被封装在一个“符号”中，构建时替换到文本文件里，类似于C语言宏定义。初期MCCP使用`#`作为“符号”标注，`//`表示人员注释，`@`表示模型注释。上述三个符号只在每一行的开头出现时具备功能性含义。
    范例：
    ```
    #define 注释1:
    {
    // 这只是一段给后来者看的玩笑性注释
    @ 此处必须使用双向链表进行实现
    }
    ```
    此后，行为描述代码中出现 `# 注释1` 的标注后，上面这段内容会在构建过程中替换符号所处位置。

5.  宏定义（暂定）：第4点中的注释例子是宏定义的表现形式之一，`#` 开头定义的符号会在构建过程中替换为实际代码。这是开发者背景（嵌入式C++程序员）的直觉判断，认为可能是必需品。MCCP本质上不是真正的编程语言，可快速演进，此特性未来可弃用，将历史版本中的宏定义替换为实际文字即可。
    为避免滥用，必须做出以下限制：
    *   宏定义的内容不应该超过7行，实际具备含义的内容不应该超过5行（非强制约定）。
    *   宏定义的嵌套不能大于3次（未来强制限制），超过3层嵌套应导致构建器报错警告并停止。
    *   宏定义不是拿来定义变量的，也不是拿来定义配置的。应善用兼容性描述文件和符号表。
    *   除结构化注释外的宏定义不应该在两个文件之间传递（未来也许强制限制）。注释型宏定义也不应在超过两个文件被使用（非强制约定，为整齐简洁）。

6.  反向构建过程（待完善，最高优先级）：期望MCCP成为桥接大模型和编程语言的通用中间件，必然要对现有历史代码进行适配。此过程由大模型进行。一系列用于反向构建的脚本会迭代化地按一定规则读取现有代码工程源码文件，首先反向转译至MCCP的符号-伪代码层。此过程中，符号表文件和兼容性描述文件会被优先构建并确定。进一步将符号-伪代码层反向转译至行为描述层的过程中，符号表文件和兼容性描述文件不再更新。此功能旨在将庞大现有历史代码纳入MCCP统一框架，最大限度利用已有工程/源码，同时利于大量企业发挥MCCP功能，为历史工程插上大模型翅膀，而非仅限于自动补全、RAG等。此功能代表一个愿景，期望将历史性代码纳入人工智能版图。
